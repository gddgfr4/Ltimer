<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>多機能トレーニングタイマー Pro — Mobile</title>
  
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root{
      --approaching-warn-color:#facc15; /* yellow-400 */
      --approaching-imminent-color:#fb923c; /* orange-400 */
      --exceeded-color:#f87171; /* red-400 */
      --work-color:#4ade80; /* green-400 */
      --rest-color:#60a5fa; /* blue-400 */
      --font-main:clamp(28px, 8vw, 40px);
      --font-live:clamp(22px, 6vw, 32px);
      --btn-h:56px;
      --master-h:64px;
      --pm-btn-h:76px;
    }
    html,body{height:100dvh;margin:0;padding:0;overflow:hidden;background:#e5e7eb;touch-action:manipulation;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif}
    .timer-font{font-variant-numeric:tabular-nums}
    .screen{position:relative; height:100%; width:100%;}
    .hidden{display:none}
    .back-btn{position:fixed; left:env(safe-area-inset-left,8px); top:calc(env(safe-area-inset-top,8px) + 8px); z-index:60;}
    .back-btn button{width:44px;height:44px;border-radius:9999px}

    /* === Split & PM Mode Layout === */
    .runner-wrap{display:flex;flex-direction:column;height:100%;}
    .runner-grid{display:grid;flex:1 1 auto;padding:6px;gap:6px;overflow:hidden;}
    .runner-card{background:#F9FAFB;border-radius:12px;padding:8px;display:grid;grid-template-columns:1fr 1fr;grid-template-rows:auto auto auto 1fr auto;gap:6px;height:100%;transition:background-color .2s; overflow:hidden;}
    .runner-card-header{grid-column:1/-1;display:grid;grid-template-columns:1fr minmax(86px,42%);gap:6px;align-items:center}
    .runner-name-input{min-width:0;text-align:left}
    .target-lap-input{min-width:0;text-align:center;padding:4px 6px}
    .runner-main-time{grid-column:1/-1;font-size:var(--font-main);font-weight:800}
    .runner-lap-live{grid-column:1/-1;font-size:var(--font-live);font-weight:800;border-radius:8px;padding:4px 6px}
    .runner-lap-history{grid-column:1/-1;overflow-y:auto;min-height:0;background:rgba(229,231,235,.8);border-radius:8px;padding:4px 6px;line-height:1.3;font-size:clamp(11px,2.8vw,13px)}
    .runner-lap-history .hist-line{margin-bottom:2px}
    .runner-lap-history .hist-n{margin-right:4px;font-weight:700}
    .runner-lap-history .hist-cum{margin-left:4px;color:#6b7280}
    .runner-actions{grid-column:1/-1;display:grid;grid-template-columns:1fr 1.6fr;gap:6px}
    .btn-lap,.btn-start{height:var(--btn-h)}

    .frame-warn10{background:#fde047!important} /* yellow-300 */
    .frame-warn5 {background:#fdba74!important} /* orange-300 */
    .frame-bad   {background:#fca5a5!important} /* red-300 */
    .pm-good { background-color: #dcfce7 !important; } /* green-100 */

    .split-master{min-height:var(--master-h);background:#1f2937;color:white;display:flex;align-items:center;justify-content:center;padding:8px}
    
    /* === Pacemaker === */
    .pm-runner-wrap {display:flex; flex-direction:column; height:100%}
    .pm-info-bar {flex-shrink:0;}
    .pm-grid{display:grid;flex:1 1 auto; padding:6px; gap:6px; overflow:hidden;}
    .pm-lane{background:#fff;border-radius:12px;padding:8px;display:grid; grid-template-rows: auto auto auto 1fr auto; gap:6px; height:100%; overflow:hidden; transition: background-color .2s;}
    .pm-main-time {font-size: var(--font-main); font-weight:800;}
    .pm-lap-live {font-size: var(--font-live); font-weight:800; border-radius:8px; padding:4px 6px;}
    .pm-lap-btn{width:100%;height:var(--pm-btn-h);font-size:clamp(16px,4vw,20px);padding:12px 16px;border-radius:14px}
    
    /* === Custom Timer === */
    .custom-runner{transition:background-color .3s}
    .work-bg{background:var(--work-color)}
    .rest-bg{background:var(--rest-color);color:#fff}
    /* Summary modal */
    .summary-modal{position:fixed;inset:0;background:rgba(0,0,0,.6);display:flex;justify-content:center;align-items:center;z-index:70;padding:16px}
    .summary-content{background:#fff;border-radius:12px;padding:16px;width:100%;max-width:680px;max-height:90vh;overflow:auto}
    .summary-table{width:100%;border-collapse:collapse;margin-top:12px}
    .summary-table th,.summary-table td{border:1px solid #d1d5db;padding:6px;text-align:center}
    .summary-table th{background:#f3f4f6}
    /* Help modal */
    .help-modal{position:fixed;inset:0;background:rgba(0,0,0,.6);display:flex;justify-content:center;align-items:center;z-index:80;padding:16px}
    .help-content{background:#fff;border-radius:12px;padding:16px;width:100%;max-width:680px;max-height:90vh;overflow:auto}
    .help-content h3{font-weight:700;margin-top:12px}
    .help-content ul{list-style:disc;padding-left:1.25rem}
  </style>
</head>
<body>
  <section id="screen-share" class="screen flex flex-col items-center justify-center gap-4 p-6">
    <h1 class="text-2xl font-bold mb-2">リアルタイム共有</h1>
    <div class="w-full max-w-sm text-center">
      <p class="text-sm text-gray-600 mb-2">
        他の人とタイマーを共有するには、同じ「合言葉」を入力してください。
      </p>
      <input id="share-passcode" type="text" placeholder="合言葉" class="w-full p-3 border rounded-md text-lg text-center">
      <button id="share-connect-btn" class="w-full mt-3 py-3 text-xl font-bold text-white bg-teal-500 rounded-lg shadow-lg">接続</button>
      <hr class="my-4">
      <button id="share-standalone-btn" class="w-full py-2 text-lg font-bold text-gray-700 bg-gray-200 rounded-lg">一人で使う</button>
    </div>
  </section>
 
  <!-- モード選択画面 -->
  <section id="screen-chooser" class="screen hidden flex flex-col items-center justify-center gap-5 p-6">
    <h1 class="text-2xl font-bold mb-2">モードを選択</h1>
    <div class="grid grid-cols-1 gap-3 w-full max-w-sm">
      <div class="grid grid-cols-3 gap-2">
        <button id="choose-split" class="col-span-2 py-4 text-xl font-bold text-white bg-indigo-600 rounded-xl shadow">ペース走</button>
        <button id="help-split" class="py-2 text-sm font-bold text-indigo-700 bg-indigo-50 rounded-xl border border-indigo-200">説明</button>
      </div>
      <div class="grid grid-cols-3 gap-2">
        <button id="choose-pm" class="col-span-2 py-4 text-xl font-bold text-white bg-green-600 rounded-xl shadow">インターバル</button>
        <button id="help-pm" class="py-2 text-sm font-bold text-green-700 bg-green-50 rounded-xl border border-green-200">説明</button>
      </div>
      <div class="grid grid-cols-3 gap-2">
        <button id="choose-custom" class="col-span-2 py-4 text-xl font-bold text-white bg-gray-800 rounded-xl shadow">タイマー</button>
        <button id="help-custom" class="py-2 text-sm font-bold text-gray-700 bg-gray-50 rounded-xl border border-gray-200">説明</button>
      </div>
    </div>
  </section>
  <!-- 戻るボタン（モード時のみ表示） -->
  <div id="back" class="back-btn hidden">
    <button class="bg-white shadow text-xl" aria-label="戻る">←</button>
  </div>
  <!-- Split -->
  <section id="screen-split" class="screen hidden">
    <div class="runner-wrap">
      <div id="split-grid" class="runner-grid"></div>
      <div id="split-master" class="split-master flex-wrap gap-x-4 gap-y-2">
        <div id="share-controls" class="hidden w-full flex-grow flex flex-col items-center text-xs px-2">
          <div id="share-status" class="mb-1">接続中...</div>
          <div class="w-full grid grid-cols-2 gap-2">
            <button id="share-ready-btn-1" class="w-full py-1 border-2 border-gray-400 rounded">ユーザー1: 準備中</button>
            <button id="share-ready-btn-2" class="w-full py-1 border-2 border-gray-400 rounded">ユーザー2: 準備中</button>
          </div>
        </div>
        <div id="standalone-controls" class="flex flex-wrap gap-x-2 sm:gap-x-4 gap-y-2 items-center justify-center">
            <button data-action="add" class="w-10 h-10 sm:w-12 sm:h-12 rounded-full bg-blue-500 text-white text-xl sm:text-2xl">+</button>
            <button data-action="remove" class="w-10 h-10 sm:w-12 sm:h-12 rounded-full bg-gray-500 text-white text-xl sm:text-2xl">−</button>
            <button data-action="start-all" class="btn px-3 text-sm sm:text-base sm:px-4 bg-green-500 rounded font-bold">START ALL</button>
            <button data-action="stop-all"  class="btn px-3 text-sm sm:text-base sm:px-4 bg-red-500 rounded font-bold">STOP ALL</button>
            <button data-action="review-reset" class="btn px-3 text-sm sm:text-base sm:px-4 bg-orange-500 rounded font-bold">結果＆リセット</button>
        </div>
      </div>
    </div>
  </section>
  <!-- Pacemaker -->
  <section id="screen-pm" class="screen hidden">
    <div id="pm-settings" class="p-4 space-y-3 overflow-y-auto h-full">
      <h2 class="text-xl font-bold text-center">インターバル設定</h2>
      <div class="grid grid-cols-2 gap-3">
        <input id="pm-distance" type="number" placeholder="距離(m)/本" class="p-2 border rounded-md text-lg" value="1000">
        <input id="pm-lap-distance" type="number" placeholder="トラック1周長 (m)" value="400" class="p-2 border rounded-md text-lg">
        <input id="pm-reps" type="number" placeholder="本数" class="p-2 border rounded-md text-lg">
        <div>
          <button id="pm-lane-minus" class="px-3 py-2 border rounded-l-md">-</button>
          <span id="pm-lane-count" class="px-4 py-2 border-t border-b">1レーン</span>
          <button id="pm-lane-plus" class="px-3 py-2 border rounded-r-md">+</button>
        </div>
        <div class="col-span-2 flex items-center gap-2">
          <input id="pm-rest-dist" type="number" placeholder="レスト距離(m)" class="p-2 border rounded-md text-lg w-full">
        </div>
      </div>
      <div id="pm-lane-targets" class="space-y-2"></div>
      <button id="pm-start-btn" class="w-full mt-1 py-3 text-2xl font-bold text-white bg-green-500 rounded-lg shadow-lg" disabled>練習開始</button>
    </div>
    <div id="pm-runner" class="hidden pm-runner-wrap">
        <div id="pm-info-bar" class="bg-gray-800 text-white text-center p-2 text-lg font-bold leading-tight"></div>
        <div id="pm-runner-grid" class="pm-grid"></div>
    </div>
  </section>
  <!-- Custom Timer -->
  <section id="screen-custom" class="screen hidden">
    <div id="custom-settings" class="p-4">
      <h2 class="text-xl font-bold text-center mb-4">タイマー設定</h2>
      <div id="custom-steps-container" class="space-y-2"></div>
      <button id="custom-add-step-btn" class="w-full mt-4 py-2 text-lg text-indigo-600 border-2 border-indigo-600 rounded-lg">ステップを追加</button>
      <div class="mt-4">
        <label for="custom-reps" class="font-bold">セット数:</label>
        <input id="custom-reps" type="number" value="1" class="w-full p-2 border rounded-md text-lg mt-1">
      </div>
      <button id="custom-start-btn" class="w-full mt-4 py-3 text-2xl font-bold text-white bg-green-500 rounded-lg shadow-lg">START</button>
    </div>
    <div id="custom-runner" class="hidden h-full flex flex-col justify-between items-center text-center p-4 custom-runner">
      <div>
        <div id="custom-runner-set-info" class="text-3xl font-bold">SET 1 / 1</div>
        <div id="custom-runner-step-info" class="text-2xl">WORK 1 / 2</div>
      </div>
      <div id="custom-runner-time" class="text-9xl font-extrabold timer-font">00:30</div>
      <div class="w-full"><button id="custom-reset-btn" class="w-full py-4 text-2xl font-bold text-gray-700 bg-gray-200 rounded-lg">RESET</button></div>
    </div>
  </section>
  <!-- Summary Modal -->
  <div id="summary" class="summary-modal hidden">
    <div class="summary-content">
      <h2 id="summary-title" class="text-2xl font-bold text-center">練習結果</h2>
      <div id="summary-table"></div>
      <div class="flex gap-4 mt-6">
        <button id="summary-csv" class="w-full py-3 text-lg font-bold text-white bg-green-600 rounded-lg">CSVダウンロード</button>
        <button id="summary-close" class="w-full py-3 text-lg font-bold text-gray-700 bg-gray-200 rounded-lg">閉じる</button>
      </div>
    </div>
  </div>
  <!-- Help Modal -->
  <div id="help" class="help-modal hidden">
    <div class="help-content">
      <div class="flex items-center justify-between">
        <h2 id="help-title" class="text-2xl font-bold">使い方</h2>
        <button id="help-close" class="px-3 py-1 bg-gray-200 rounded">閉じる</button>
      </div>
      <div id="help-body" class="mt-3 text-sm leading-relaxed"></div>
    </div>
  </div>
  
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    /* ==================================
     * ボタン効果（サウンドと視覚）
     * ================================== */
    let audioCtx;
    function playClickSound() {
        if (typeof AudioContext === 'undefined' && typeof webkitAudioContext === 'undefined') return;
        if (!audioCtx) {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            } catch(e) { console.error("AudioContext could not be created.", e); return; }
        }
        if (audioCtx.state === 'suspended') { audioCtx.resume(); }
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(700, audioCtx.currentTime);
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.1);
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.1);
    }

    function applyPressEffect(element) {
        element.style.transition = 'transform 0.05s ease-in-out';
        element.style.transform = 'scale(0.96)';
        setTimeout(() => { element.style.transform = 'scale(1)'; }, 100);
    }
    
    function handleButtonInteraction(e) {
        if(e) e.stopPropagation();
        const target = e ? e.currentTarget : this;
        playClickSound();
        applyPressEffect(target);
    }
    
    /* ==================================
     * ユーティリティ関数
     * ================================== */
    function fmt(ms) {
      if (typeof ms !== 'number' || !isFinite(ms)) return '00:00.00';
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
      const seconds = (totalSeconds % 60).toString().padStart(2, '0');
      const milliseconds = Math.floor((ms % 1000) / 10).toString().padStart(2, '0');
      return `${minutes}:${seconds}.${milliseconds}`;
    }

    function fmtCustom(s) {
        if (typeof s !== 'number' || !isFinite(s)) return '00:00';
        const totalSeconds = Math.ceil(s);
        const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
        const seconds = (totalSeconds % 60).toString().padStart(2, '0');
        return `${minutes}:${seconds}`;
    }

    /* ==================================
     * Firebase & 共有設定
     * ================================== */
    const firebaseConfig = {
      apiKey: "AIzaSyA8oCOusnqZCSax9ZY3-n4KNt2AxEmvT-E",
      authDomain: "athlog-126d2.firebaseapp.com",
      databaseURL: "https://athlog-126d2-default-rtdb.firebaseio.com", // ← この行を追加
      projectId: "athlog-126d2",
      storageBucket: "athlog-126d2.appspot.com",
      messagingSenderId: "784178114661",
      appId: "1:784178114661:web:d41103b0dad1187b85168c"
    };
 
    let firebaseApp, database, firestore, athlogTeamId, athlogMemberId;
    let teamMembers = []; // チームメンバーのリストを保持
    let memberNameMap = {};
    try {
      if (!firebase.apps.length) {
        firebaseApp = firebase.initializeApp(firebaseConfig);
      } else {
        firebaseApp = firebase.app();
      }
      database = firebase.database();
      firestore = firebase.firestore();
    } catch (e) { console.error("Firebaseの初期化に失敗。"); }

    const urlParams = new URLSearchParams(window.location.search);
    athlogTeamId = urlParams.get('team');
    athlogMemberId = urlParams.get('member');
    
    if (athlogMemberId) {
        const shareTitle = document.querySelector('#screen-share h1');
        const shareDesc = document.querySelector('#screen-share .text-sm');
        shareTitle.textContent = `こんにちは、${athlogMemberId}さん`;
        shareDesc.textContent = 'タイマーを共有するには、相手と同じ「合言葉」を入力してください。';
    }

    // 【変更後】
    async function fetchTeamMembers() {
        if (!firestore || !athlogTeamId) {
            teamMembers = [];
            memberNameMap = {}; // マップもクリア
            return;
        }
        try {
            const membersSnapshot = await firestore.collection('teams').doc(athlogTeamId).collection('members').get();
            const membersData = membersSnapshot.docs.map(doc => ({
                id: doc.id,
                name: doc.data()?.name || doc.id // nameフィールドがなければIDを使用
            }));
            
            // IDでソート
            membersData.sort((a, b) => a.id.localeCompare(b.id)); 
            
            teamMembers = membersData.map(m => m.id); // IDのリスト
            memberNameMap = membersData.reduce((map, member) => {
                map[member.id] = member.name; // IDと名前のマッピングを作成
                return map;
            }, {});
            
        } catch (e) {
            console.error("チームメンバーの取得に失敗しました:", e);
            teamMembers = [];
            memberNameMap = {};
        }
    }
    function ymd(d){
      const date = new Date(d.getTime() - d.getTimezoneOffset()*60000);
      return date.toISOString().slice(0,10);
    }
    
    async function writeToAthlogJournalForMember(targetMemberId, summaryText) {
        if (!firestore || !athlogTeamId || !targetMemberId) {
            console.log("AthLog連携情報が不完全なため、書き込みをスキップします。", { team: athlogTeamId, member: targetMemberId });
            return;
        }
        const today = ymd(new Date());
        const docRef = firestore.collection('teams').doc(athlogTeamId)
                                .collection('members').doc(targetMemberId)
                                .collection('journal').doc(today);
        try {
            await firestore.runTransaction(async (tx) => {
                const doc = await tx.get(docRef);
                const currentFeel = doc.data()?.feel || '';
                const header = `【Ltimer計測結果 by ${getDisplayName(athlogMemberId) || 'タイマー'}】\n`;
                const newFeel = currentFeel ? `${currentFeel}\n\n${header}${summaryText}` : `${header}${summaryText}`;
                tx.set(docRef, { feel: newFeel }, { merge: true });
            });
            console.log(`AthLogの日誌（${today}）に${getDisplayName(targetMemberId)}の結果を保存しました。`);
        } catch (e) {
            console.error(`AthLog日誌（${getDisplayName(targetMemberId)}）への書き込みに失敗:`, e);
            throw e; // エラーを呼び出し元に伝える
        }
    }
    let sessionRef = null, watches = [], userId = null, sessionPasscode = '';
    const SESSION_EXPIRATION_MS = 3 * 60 * 60 * 1000;

    async function showSummary(data, onCloseCallback) {
        const summaryTableContainer = document.getElementById('summary-table');
        const summaryModal = document.getElementById('summary');
        let tableHtml = '<table class="summary-table">';
        
        const writePromises = [];

        data.forEach(item => {
            if (!item.laps || item.laps.length === 0) return;
            const memberToLog = item.name;
            const displayName = getDisplayName(targetMemberId || 'タイマー ' + item.id;

            tableHtml += `<thead><tr><th colspan="3">${displayName}</th></tr>`;
            tableHtml += `<tr><th>Lap</th><th>Time</th><th>Cumulative</th></tr></thead><tbody>`;
            
            let summaryTextForAthlog = `【ペース走 結果: ${displayName}】\n`;
            let cum = 0;
            item.laps.forEach((lap, i) => {
                cum += lap;
                tableHtml += `<tr><td>${i+1}</td><td>${fmt(lap)}</td><td>${fmt(cum)}</td></tr>`;
                summaryTextForAthlog += `Lap ${i+1}: ${fmt(lap)} (${fmt(cum)})\n`;
            });
            tableHtml += '</tbody>';

            if (memberToLog && teamMembers.includes(memberToLog)) {
                 writePromises.push(writeToAthlogJournalForMember(memberToLog, summaryTextForAthlog.trim()));
            }
        });
        tableHtml += '</table>';
        summaryTableContainer.innerHTML = tableHtml;
        summaryModal.classList.remove('hidden');
        
        if (writePromises.length > 0) {
            try {
                await Promise.all(writePromises);
                alert(`${writePromises.length}件の記録をAthLog日誌に保存しました。`);
            } catch (error) {
                alert("日誌への一部またはすべての書き込みに失敗しました。コンソールで詳細を確認してください。");
            }
        }

        document.getElementById('summary-close').onclick = () => {
            summaryModal.classList.add('hidden');
            if (onCloseCallback) onCloseCallback();
        };
    }
    
    async function showPmSummary(){
        const summaryTableContainer = document.getElementById('summary-table');
        const summaryModal = document.getElementById('summary');
        let tableHtml = '<table class="summary-table">';
        const writePromises = [];
        
        pmState.lanes.forEach(lane => {
             const memberToLog = lane.name;
             const displayName = getDisplayName(memberIdToLog) || `レーン ${lane.id}`;
             tableHtml += `<thead><tr><th colspan="4">${displayName}</th></tr>`;
             tableHtml += `<tr><th>Lap</th><th>Lap Time</th><th>Rep Time</th><th>Pace Diff</th></tr></thead><tbody>`;
             
             let summaryTextForAthlog = `【インターバル 結果: ${displayName}】\n`;
             lane.laps.forEach(lap => {
                if(lap.event.type.startsWith('START') && lap.event.distanceInRep === 0) return;
                let paceDiff = '---';
                if(lane.pace > 0){
                    const targetCumulativeTime = lap.event.distanceInRep * lane.pace;
                    const diff = targetCumulativeTime - lap.totalRepTime;
                    const diffSign = diff >= 0 ? '-' : '+';
                    paceDiff = `${diffSign}${fmt(Math.abs(diff))}`;
                }
                tableHtml += `<tr><td>${lap.event.type}</td><td>${fmt(lap.lapTime)}</td><td>${fmt(lap.totalRepTime)}</td><td>${paceDiff}</td></tr>`;
                summaryTextForAthlog += `${lap.event.type}: ${fmt(lap.lapTime)} (${fmt(lap.totalRepTime)})\n`;
             });
             tableHtml += `</tbody>`;

             if (memberToLog && teamMembers.includes(memberToLog)) {
                writePromises.push(writeToAthlogJournalForMember(memberToLog, summaryTextForAthlog.trim()));
             }
        });
        tableHtml += '</table>';
        summaryTableContainer.innerHTML = tableHtml;
        summaryModal.classList.remove('hidden');

        if (writePromises.length > 0) {
            try {
                await Promise.all(writePromises);
                alert(`${writePromises.length}件の記録をAthLog日誌に保存しました。`);
            } catch(e) {
                alert("日誌への一部またはすべての書き込みに失敗しました。");
            }
        }

        document.getElementById('summary-close').onclick = () => {
            summaryModal.classList.add('hidden');
            initPacemaker();
        };
    }


    // 【変更前】(この関数の定義がない)

// 【変更後】(ユーティリティ関数の後あたりに追加)
/**
 * メンバーIDから表示名を取得する（マップに無ければIDをそのまま返す）
 * @param {string} memId メンバーID
 * @returns {string} 表示名
 */
function getDisplayName(memId){
  // マップに名前があればそれを返し、なければIDを返す
  return memberNameMap[memId] || memId;
}
    /* ==================================
     * 画面要素の取得
     * ================================== */
    const screens = {
      share: document.getElementById('screen-share'),
      chooser: document.getElementById('screen-chooser'),
      split: document.getElementById('screen-split'),
      pm: document.getElementById('screen-pm'),
      custom: document.getElementById('screen-custom'),
    };
    const backWrap = document.getElementById('back');
    let currentScreen = 'share';
 
    const shareControls = document.getElementById('share-controls');
    const standaloneControls = document.getElementById('standalone-controls');
    const readyBtn1 = document.getElementById('share-ready-btn-1');
    const readyBtn2 = document.getElementById('share-ready-btn-2');

    /* ==================================
     * ヘルプモーダル
     * ================================== */
    const helpModal = document.getElementById('help');
    const helpTitle = document.getElementById('help-title');
    const helpBody = document.getElementById('help-body');
    const helpContent = {
        split: {
            title: 'ペース走モードの使い方',
            body: `
                <p>最大6人まで同時にタイムを計測できるストップウォッチです。</p>
                <ul class="list-disc pl-5 mt-2 space-y-1">
                    <li><strong>+/-ボタン:</strong> タイマーの数を増減します。</li>
                    <li><strong>START ALL/STOP ALL:</strong> 全てのタイマーを同時に操作します。</li>
                    <li><strong>結果＆リセット:</strong> タイムを記録している場合、結果を表示してから全てのタイマーをリセットします。</li>
                    <li><strong>タイマー名:</strong> AthLogから開いた場合、チームメンバーを選択できます。選択すると、そのメンバーの日誌に結果が自動保存されます。</li>
                    <li><strong>目標(sec):</strong> 各タイマーに目標ラップタイム（秒）を設定すると、ペースに応じて背景色が変化します。</li>
                </ul>
            `
        },
        pm: {
            title: 'インターバルモードの使い方',
            body: `
                <p>複雑なインターバル練習のラップを自動で計算・計測するモードです。</p>
                <h3 class="font-bold mt-2">設定項目</h3>
                <ul class="list-disc pl-5 mt-1 space-y-1">
                    <li><strong>距離/本:</strong> 1本あたりの走行距離。</li>
                    <li><strong>トラック1周長:</strong> 計測者がいる周回コースの1周の距離。</li>
                    <li><strong>本数:</strong> 練習の本数。</li>
                    <li><strong>レスト距離:</strong> 各本の間のつなぎの距離。</li>
                    <li><strong>レーン目標:</strong> 1本あたりの目標タイムを設定すると、ペースに応じて背景色が変化します。</li>
                </ul>
                <h3 class="font-bold mt-2">計測方法</h3>
                <p>物理法則に基づき、スタート地点や測定者の前を通過するタイミングを自動計算します。画面のボタンに表示される指示（START/PASS/FINISH）に従ってボタンを押してください。</p>
            `
        },
        custom: {
            title: 'タイマーモードの使い方',
            body: `
                <p>「運動」と「休憩」を組み合わせたオリジナルのタイマーを作成できます。</p>
                 <ul class="list-disc pl-5 mt-2 space-y-1">
                    <li><strong>ステップを追加:</strong> WORK(運動)またはREST(休憩)のステップを追加します。</li>
                    <li><strong>セット数:</strong> 作成したステップの組み合わせを繰り返す回数を設定します。</li>
                    <li><strong>START:</strong> 作成したタイマーを開始します。タイマー作動中は背景色が変化します。</li>
                </ul>
            `
        }
    };
    function showHelp(mode) {
        if (!helpContent[mode]) return;
        helpTitle.textContent = helpContent[mode].title;
        helpBody.innerHTML = helpContent[mode].body;
        helpModal.classList.remove('hidden');
    }
    document.getElementById('help-split').onclick = (e) => { handleButtonInteraction(e); showHelp('split'); };
    document.getElementById('help-pm').onclick = (e) => { handleButtonInteraction(e); showHelp('pm'); };
    document.getElementById('help-custom').onclick = (e) => { handleButtonInteraction(e); showHelp('custom'); };
    document.getElementById('help-close').onclick = (e) => { handleButtonInteraction(e); helpModal.classList.add('hidden'); };


    /* ==================================
     * 画面遷移ロジック
     * ================================== */
    function showScreen(screenName) {
      Object.values(screens).forEach(el => el.classList.add('hidden'));
      screens[screenName].classList.remove('hidden');
      currentScreen = screenName;
      backWrap.classList.toggle('hidden', ['share', 'chooser'].includes(screenName));
      if (screenName === 'chooser') updateChooserView();
      if (screenName === 'split') recalibrateSplitLayout();
    }
    showScreen('share');
 
    /* ==================================
     * 共有モード接続処理
     * ================================== */
    document.getElementById('share-connect-btn').onclick = (e) => {
      handleButtonInteraction(e);
      sessionPasscode = document.getElementById('share-passcode').value.trim();
      if (!sessionPasscode) return alert('合言葉を入力してください');
      connectToSession();
    };
 
    document.getElementById('share-standalone-btn').onclick = (e) => {
      handleButtonInteraction(e);
      sessionRef = null;
      userId = null;
      showScreen('chooser');
    };
 
    function connectToSession() {
      if (!database) return alert("共有機能の初期化に失敗しました。");
      sessionRef = database.ref('sessions/' + sessionPasscode);
      sessionRef.once('value', snapshot => {
          const sessionData = snapshot.val();
          const now = Date.now();
          if (sessionData && sessionData.createdAt && (now - sessionData.createdAt > SESSION_EXPIRATION_MS)) {
              sessionRef.remove().then(() => joinSession(true));
          } else {
              joinSession(sessionData === null);
          }
      });
    }
 
    // ▼▼▼ この関数全体を置き換えてください ▼▼▼
    function joinSession(isNewSession) {
        const myName = getDisplayName(athlogMemberId) || `ゲスト${String(Date.now()).slice(-4)}`;
        sessionRef.child('users').transaction(currentUsers => {
            currentUsers = currentUsers || {};

            // 自分が既にセッションに存在するか確認（再接続ケース）
            let existingUserKey = null;
            for (const key in currentUsers) {
                if (currentUsers[key].name === myName) {
                    existingUserKey = key;
                    break;
                }
            }

            if (existingUserKey) {
                // 既に存在する場合、自分のIDを設定して接続状態を更新
                userId = existingUserKey;
                currentUsers[userId].connected = true;
                return currentUsers;
            }

            // 新規参加の場合、空いているスロットを探す
            if (!currentUsers.user1) {
                userId = 'user1';
                currentUsers.user1 = { connected: true, ready: false, name: myName };
            } else if (!currentUsers.user2) {
                userId = 'user2';
                currentUsers.user2 = { connected: true, ready: false, name: myName };
            } else {
                // セッションが満員の場合は中断
                return; 
            }
            return currentUsers;

        }).then(result => {
            if (!result.committed || !userId) {
                alert('このセッションは満員です。');
                sessionRef = null;
                return;
            }
            if (isNewSession && userId === 'user1') {
                sessionRef.child('createdAt').set(firebase.database.ServerValue.TIMESTAMP);
            }
            const myUserRef = sessionRef.child('users').child(userId);
            myUserRef.onDisconnect().update({ connected: false });
            listenToSessionChanges();
            showScreen('split');
            initSplit(true);
        }).catch(error => {
            console.error("Firebase Transaction Failed:", error);
            alert("接続に失敗しました。データベースの権限設定を確認してください。\nエラー: " + error.message);
        });
    }
    // ▲▲▲ ここまで ▲▲▲
 
    function listenToSessionChanges() {
      sessionRef.on('value', (snapshot) => {
        if (!snapshot.exists()) return;
        const sessionData = snapshot.val();
        updateUsersStatusUI(sessionData.users);
        const newWatches = sessionData.watches || [];
        if (JSON.stringify(watches) !== JSON.stringify(newWatches)) {
          watches = newWatches;
          if(currentScreen === 'split') renderSplit();
        }
      });
    }
    
    function updateUsersStatusUI(users) {
        if (!users || shareControls.classList.contains('hidden')) return;

        const user1 = users.user1 || {};
        const user2 = users.user2 || {};
        const user1Name = user1.name || 'ユーザー1';
        const user2Name = user2.name || 'ユーザー2';

        const updateBtn = (btn, user, userName) => {
            btn.textContent = `${userName}: ${user.connected ? (user.ready ? '準備OK' : '準備中') : '未接続'}`;
            btn.classList.remove('border-gray-400', 'border-green-500', 'border-red-500');
            if (!user.connected) {
                btn.classList.add('border-red-500');
            } else if (user.ready) {
                btn.classList.add('border-green-500');
            } else {
                btn.classList.add('border-gray-400');
            }
        };

        updateBtn(readyBtn1, user1, user1Name);
        updateBtn(readyBtn2, user2, user2Name);
        
        const statusEl = document.getElementById('share-status');
        if (user1.connected && user2.connected) {
            statusEl.textContent = '2人接続済み';
            if (user1.ready && user2.ready) {
                statusEl.textContent = '両者準備OK！操作できます。';
            }
        } else {
            statusEl.textContent = '相手の接続を待っています...';
        }
    }
    
    readyBtn1.onclick = (e) => { handleButtonInteraction(e); if(userId === 'user1') toggleReady(); };
    readyBtn2.onclick = (e) => { handleButtonInteraction(e); if(userId === 'user2') toggleReady(); };
    function toggleReady() {
        if (!sessionRef || !userId) return;
        const myReadyRef = sessionRef.child('users').child(userId).child('ready');
        myReadyRef.transaction((currentReadyState) => {
            return !currentReadyState;
        });
    }

    /* ==================================
     * アプリ基本機能
     * ================================== */
    function updateChooserView() {
        const isShared = !!sessionRef;
        ['choose-pm', 'choose-custom'].forEach(id => {
            const btn = document.getElementById(id);
            btn.disabled = isShared;
            btn.classList.toggle('bg-gray-400', isShared);
            btn.classList.toggle('cursor-not-allowed', isShared);
            btn.classList.toggle('opacity-50', isShared);
            if(id === 'choose-pm') btn.classList.toggle('bg-green-600', !isShared);
            if(id === 'choose-custom') btn.classList.toggle('bg-gray-800', !isShared);
        });
    }

    document.getElementById('choose-split').onclick = async (e) => {
      handleButtonInteraction(e);
      await fetchTeamMembers();
      initSplit(!!sessionRef);
      showScreen('split');
    };
    document.getElementById('choose-pm').onclick = async (e) => { 
        if(!e.currentTarget.disabled) { 
            handleButtonInteraction(e); 
            await fetchTeamMembers();
            initPacemaker(); 
            showScreen('pm'); 
        } 
    };
    document.getElementById('choose-custom').onclick = (e) => { if(!e.currentTarget.disabled) { handleButtonInteraction(e); initCustom(); showScreen('custom'); } };
    
    backWrap.querySelector('button').onclick = (e) => {
        handleButtonInteraction(e);
        stopCustomTimer();
        if (pmState && pmState.lanes) {
            pmState.lanes.forEach(l => {
                l.running = false;
            });
        }
        if(sessionRef && userId) {
            sessionRef.child('users').child(userId).remove();
            sessionRef.off(); sessionRef = null; userId = null;
        }
        showScreen('chooser');
    };
   
    /* ====== Split Mode ====== */
    const splitGrid = document.getElementById('split-grid');

    function updateSharedWatches(updateLogic) {
        if (!sessionRef) {
            watches = updateLogic(watches || []);
            renderSplit();
            return;
        }
        sessionRef.child('watches').transaction(currentWatches => {
            return updateLogic(currentWatches || []);
        });
    }
   
    function initSplit(isShared) {
      shareControls.classList.toggle('hidden', !isShared);
      standaloneControls.classList.toggle('hidden', isShared && !userId);
      
      const firstMemberName = (teamMembers && teamMembers.length > 0) ? teamMembers[0] : '';
      const initialWatches = [{id:0,name:firstMemberName,running:false,start:0,elapsed:0,lastLap:0,laps:[],target:0}];

      if (isShared) {
        sessionRef.child('watches').transaction(currentData => {
            if (currentData === null) {
                return initialWatches;
            }
            return; 
        });
      } else {
        watches = initialWatches;
        renderSplit();
      }
    }
 
    function renderSplit(){
      splitGrid.innerHTML = watches.map(sw=>{
        let cum=0; const hist = (sw.laps || []).map((lap,i)=>{cum+=lap; return {n:i+1,lap,cum};}).slice().reverse()
          .map(h=>`<div class="hist-line"><span class="hist-n">${h.n}</span> ${fmt(h.lap)} <span class="hist-cum">(${fmt(h.cum)})</span></div>`).join('') || '<p class="text-xs text-center text-gray-400">ラップ履歴</p>';
        
        const memberOptions = (teamMembers || []).map(memId => 
            `<option value="${memId}" ${sw.name === memId ? 'selected' : ''}>${getDisplayName(memId)}</option>` // 表示名を getDisplayName で取得
        ).join('');
        
        return `<div class="runner-card" id="w-${sw.id}">
          <button data-id="${sw.id}" data-action="delete" class="absolute top-2 right-2 w-6 h-6 bg-gray-300 text-gray-700 rounded-full flex items-center justify-center text-lg font-bold hover:bg-red-500 hover:text-white">×</button>
          <div class="runner-card-header">
            ${(athlogTeamId && teamMembers.length > 0) ? `
              <select data-id="${sw.id}" class="runner-name-input p-1 bg-gray-100 rounded font-bold">
                <option value="">-- 選手を選択 --</option>
                ${memberOptions}
              </select>
            ` : `
              <input type="text" value="${getDisplayName(sw.name) || 'タイマー ' + (sw.id+1)}" data-id="${sw.id}" class="runner-name-input p-1 bg-gray-100 rounded font-bold">
            `}
            <input type="number" data-id="${sw.id}" placeholder="目標(sec)" value="${(sw.target||0)>0?sw.target:''}" class="target-lap-input border-2 rounded">
          </div>
          <div class="runner-main-time timer-font">${fmt(sw.elapsed)}</div>
          <div class="runner-lap-live timer-font" id="live-${sw.id}">${fmt(sw.elapsed - sw.lastLap)}</div>
          <div class="runner-lap-history">${hist}</div>
          <div class="runner-actions">
            <button data-id="${sw.id}" data-action="start" class="btn-start text-white font-bold rounded ${sw.running?'bg-red-500':'bg-green-500'}">${sw.running?'STOP':'START'}</button>
            <button data-id="${sw.id}" data-action="lap" class="btn-lap text-white font-bold rounded bg-gray-700">LAP (${(sw.laps||[]).length+1})</button>
          </div>
        </div>`; }).join('');
      recalibrateSplitLayout();
      wireSplit();
    }
 
    function wireSplit() {
      splitGrid.querySelectorAll('button[data-action="delete"]').forEach(btn => {
          btn.onclick = (e) => {
              handleButtonInteraction(e);
              const idToDelete = +e.currentTarget.dataset.id;
              updateSharedWatches(currentWatches => {
                  if (currentWatches.length <= 1) return currentWatches;
                  return currentWatches.filter(w => w.id !== idToDelete);
              });
          };
      });

      splitGrid.querySelectorAll('.runner-name-input, .target-lap-input').forEach(el => {
        el.onchange = (e) => {
            const id = +e.currentTarget.dataset.id;
            const classList = e.currentTarget.classList;
            const value = e.currentTarget.value;
            
            updateSharedWatches(currentWatches => {
                const sw = currentWatches.find(w => w.id === id);
                if (!sw) return currentWatches;
                if (classList.contains('runner-name-input')) sw.name = value;
                else if (classList.contains('target-lap-input')) sw.target = parseFloat(value) || 0;
                return currentWatches;
            });
        };
      });

      splitGrid.querySelectorAll('.runner-actions button').forEach(btn => {
        btn.onclick = (e) => {
          handleButtonInteraction(e);
          const {id, action} = e.currentTarget.dataset;
          updateSharedWatches(currentWatches => {
            const sw = currentWatches.find(w => w.id === +id);
            if (!sw) return currentWatches;
            const now = Date.now();

            if (action === 'start') {
              sw.running = !sw.running;
              if (sw.running) {
                  sw.start = now - sw.elapsed;
              } else {
                  sw.elapsed = now - sw.start;
              }
            } else if (action === 'lap' && sw.running) {
              sw.laps = sw.laps || [];
              const currentElapsed = now - sw.start;
              const lapTime = currentElapsed - sw.lastLap;
              sw.laps.push(lapTime);
              sw.lastLap = currentElapsed;
              
              setTimeout(() => {
                const liveEl = document.querySelector(`#w-${id} .runner-lap-live`);
                if (liveEl) {
                    liveEl.textContent = fmt(lapTime);
                    liveEl.dataset.frozen = "true";
                    setTimeout(() => { delete liveEl.dataset.frozen; }, 3000);
                }
              }, 50);
            }
            return currentWatches;
          });
        }
      });
      
      standaloneControls.querySelectorAll('button').forEach(b => {
        b.onclick = (e) => {
          handleButtonInteraction(e);
          const {action} = e.currentTarget.dataset;
          updateSharedWatches(currentWatches => {
            if (action === 'add') {
                const limit = sessionRef ? 4 : 6;
                if (currentWatches.length < limit) {
                    const newId = currentWatches.length > 0 ? Math.max(...currentWatches.map(w => w.id)) + 1 : 0;
                    currentWatches.push({id:newId, name:'', running:false, start:0, elapsed:0, lastLap:0, laps:[], target:0});
                }
            } else if (action === 'remove') {
                if (currentWatches.length > 1) {
                    currentWatches.pop();
                }
            } else if (action === 'start-all') {
                const now = Date.now();
                currentWatches.forEach(w => { if(!w.running){ w.running = true; w.start = now - w.elapsed; }});
            } else if (action === 'stop-all') {
                const now = Date.now();
                currentWatches.forEach(w => {
                    if (w.running) {
                        w.running = false;
                        w.elapsed = now - w.start;
                    }
                });
            } else if (action === 'review-reset' && !currentWatches.some(w=>w.running)) {
                if (currentWatches.some(w => w.laps && w.laps.length > 0)) {
                    showSummary(currentWatches, () => {
                        updateSharedWatches(watches => {
                           const firstMemberName = (teamMembers && teamMembers.length > 0) ? teamMembers[0] : '';
                           return [{id:0,name:firstMemberName,running:false,start:0,elapsed:0,lastLap:0,laps:[],target:0}];
                        });
                    });
                } else {
                   const firstMemberName = (teamMembers && teamMembers.length > 0) ? teamMembers[0] : '';
                   return [{id:0,name:firstMemberName,running:false,start:0,elapsed:0,lastLap:0,laps:[],target:0}];
                }
            }
            return currentWatches;
          });
        }
      });
    }
 
    function tickSplit() {
      const now = Date.now();
      
      watches.forEach(sw => {
          const card = document.getElementById('w-' + sw.id);
          if (!card) return;

          const currentElapsed = sw.running ? (now - sw.start) : sw.elapsed;
          const currentLapElapsed = sw.running ? (currentElapsed - sw.lastLap) : (sw.elapsed - sw.lastLap);

          const liveEl = card.querySelector('.runner-lap-live');
          
          card.querySelector('.runner-main-time').textContent = fmt(currentElapsed);

          if (!liveEl.dataset.frozen) {
              liveEl.textContent = fmt(currentLapElapsed);
          }

          if (sw.target > 0 && sw.running) {
              const diff = (sw.target * 1000) - currentLapElapsed;
              card.classList.remove('frame-warn10', 'frame-warn5', 'frame-bad');
              if (diff < 0) card.classList.add('frame-bad');
              else if (diff <= 5000) card.classList.add('frame-warn5');
              else if (diff <= 10000) card.classList.add('frame-warn10');
          } else {
              card.classList.remove('frame-warn10', 'frame-warn5', 'frame-bad');
          }
      });
    }

    /* ====== Pacemaker Mode ====== */
    let pmState = {};
    
    function initPacemaker() {
        pmState = {};
        document.getElementById('pm-settings').classList.remove('hidden');
        document.getElementById('pm-runner').classList.add('hidden');
        renderPmSettings();
        wirePmSettings();
        validatePmSettings();
    }
    
    function renderPmSettings(laneCount = 1) {
        const container = document.getElementById('pm-lane-targets');
        container.innerHTML = '';
        document.getElementById('pm-lane-count').textContent = `${laneCount}レーン`;

        const memberOptions = (teamMembers || []).map(memId => 
            `<option value="${memId}" ${sw.name === memId ? 'selected' : ''}>${getDisplayName(memId)}</option>` // 表示名を getDisplayName で取得
        ).join('');
          
        for (let i = 1; i <= laneCount; i++) {
            const selectedMember = (teamMembers && teamMembers[i-1]) ? `selected` : '';
            container.innerHTML += `
                <div class="grid grid-cols-4 gap-2 items-center">
                    ${(athlogTeamId && teamMembers.length > 0) ? `
                      <select data-lane-id="${i}" class="pm-lane-name col-span-2 p-2 border rounded-md">
                        <option value="">-- 選手を選択 --</option>
                        ${(teamMembers || []).map(memId => `<option value="${memId}" ${memId === selectedMemberId ? 'selected' : ''}>${getDisplayName(memId)}</option>`).join('')} // 表示名を getDisplayName で取得
                      </select>
                    ` : `
                      <input type="text" value="レーン ${i}" data-lane-id="${i}" class="pm-lane-name col-span-2 p-2 border rounded-md">
                    `}
                    <input type="number" data-lane-id="${i}" class="pm-target-min col-span-1 p-2 border rounded-md" placeholder="分">
                    <input type="number" data-lane-id="${i}" class="pm-target-sec col-span-1 p-2 border rounded-md" placeholder="秒">
                </div>`;
        }
    }

    function wirePmSettings() {
        const laneCountEl = document.getElementById('pm-lane-count');
        document.getElementById('pm-settings').oninput = validatePmSettings;
        
        document.getElementById('pm-lane-plus').onclick = (e) => {
            handleButtonInteraction(e);
            let count = parseInt(laneCountEl.textContent);
            if (count < 4) renderPmSettings(count + 1);
        };
        document.getElementById('pm-lane-minus').onclick = (e) => {
            handleButtonInteraction(e);
            let count = parseInt(laneCountEl.textContent);
            if (count > 1) renderPmSettings(count - 1);
        };
        document.getElementById('pm-start-btn').onclick = (e) => {
            if (e.currentTarget.disabled) return;
            handleButtonInteraction(e);
            startPacemaker();
        };
    }

    function validatePmSettings() {
        const startBtn = document.getElementById('pm-start-btn');
        const {value: distance} = document.getElementById('pm-distance');
        const {value: lapDistance} = document.getElementById('pm-lap-distance');
        const {value: reps} = document.getElementById('pm-reps');
        const isValid = distance && lapDistance && reps;
        startBtn.disabled = !isValid;
        startBtn.classList.toggle('opacity-50', !isValid);
        startBtn.classList.toggle('cursor-not-allowed', !isValid);
    }

    function generateLapSchedule(settings) {
        const { W, N, R, L } = settings;
        const W_arr = Array(N).fill(W);
        const R_arr = Array(N - 1).fill(R);

        const D_total = W_arr.reduce((a, b) => a + b, 0) + R_arr.reduce((a, b) => a + b, 0);
        let currentPos = (-D_total % L + L) % L;

        const schedule = [];
        let totalDistance = 0;

        for (let i = 0; i < N; i++) {
            const rep = i + 1;
            const repDist = W_arr[i];
            
            schedule.push({ rep, type: `START(${rep})`, distanceInRep: 0, totalDistance });

            const k_max = Math.floor((currentPos + repDist) / L);
            for (let k = 1; k <= k_max; k++) {
                const passDist = (L - currentPos) + (k - 1) * L;
                if (passDist > 0 && passDist < repDist) {
                    schedule.push({ rep, type: `PASS(${passDist}m)`, distanceInRep: passDist, totalDistance: totalDistance + passDist });
                }
            }
            
            schedule.push({ rep, type: `FINISH(${rep})`, distanceInRep: repDist, totalDistance: totalDistance + repDist });
            
            currentPos = (currentPos + repDist) % L;
            totalDistance += repDist;

            if (i < N - 1) {
                const restDist = R_arr[i];
                currentPos = (currentPos + restDist) % L;
                totalDistance += restDist;
            }
        }
        
        return schedule.filter((v, i, a) => a.findIndex(t => (t.totalDistance === v.totalDistance)) === i)
                       .sort((a,b) => a.totalDistance - b.totalDistance);
    }
    
    function startPacemaker() {
        const settings = {
            W: +document.getElementById('pm-distance').value,
            L: +document.getElementById('pm-lap-distance').value,
            N: +document.getElementById('pm-reps').value,
            R: +document.getElementById('pm-rest-dist').value || 0,
        };
        const lanes = [];
        for (let i = 1; i <= +document.getElementById('pm-lane-count').textContent[0]; i++) {
            const min = +document.querySelector(`.pm-target-min[data-lane-id="${i}"]`).value || 0;
            const sec = +document.querySelector(`.pm-target-sec[data-lane-id="${i}"]`).value || 0;
            const nameEl = document.querySelector(`.pm-lane-name[data-lane-id="${i}"]`);
            const name = nameEl.value.trim() || `レーン ${i}`;
            const targetTimePerRep = (min * 60 + sec) * 1000;
            lanes.push({
                id: i, name: name, targetTime: targetTimePerRep,
                pace: targetTimePerRep > 0 ? targetTimePerRep / settings.W : 0,
                laps: [], lastLapTime: 0, displayFrozen: false,
                running: false, paused: false, repStartTime: 0, lapStartTime: 0, nextLapIndex: 0
            });
        }
        pmState = {
            settings, lanes, lapSchedule: generateLapSchedule(settings)
        };
        renderPmRunner();
        wirePmRunner();
        document.getElementById('pm-settings').classList.add('hidden');
        document.getElementById('pm-runner').classList.remove('hidden');
        updatePmDisplays();
    }

    function renderPmRunner() {
        const grid = document.getElementById('pm-runner-grid');
        grid.innerHTML = pmState.lanes.map(lane => `
            <div class="pm-lane" id="pm-lane-${lane.id}">
                <p class="text-xl font-bold">${lane.name}</p>
                <div class="pm-main-time timer-font">${fmt(0)}</div>
                <div class="pm-lap-live timer-font">${fmt(0)}</div>
                <div class="runner-lap-history" id="pm-history-${lane.id}">ラップ履歴</div>
                <div class="flex flex-col justify-center items-center">
                    <button data-lane-id="${lane.id}" class="pm-lap-btn bg-blue-500 text-white font-bold">START</button>
                    <p class="text-sm text-gray-500 mt-1" id="pm-target-info-${lane.id}">次の目標: ---</p>
                </div>
            </div>`).join('');
        recalibratePmLayout();
    }

    function wirePmRunner() {
        document.querySelectorAll('.pm-lap-btn').forEach(btn => {
            btn.onclick = (e) => {
                handleButtonInteraction(e);
                const now = Date.now();
                const laneId = parseInt(e.currentTarget.dataset.laneId);
                const lane = pmState.lanes.find(l => l.id === laneId);
                if (!lane) return;

                const eventIndex = lane.nextLapIndex;
                if (eventIndex >= pmState.lapSchedule.length) return;
                const event = pmState.lapSchedule[eventIndex];
                
                if (event.type.startsWith('START')) {
                    lane.running = true;
                    lane.paused = false;
                    lane.repStartTime = lane.lapStartTime = now;
                    if (event.rep === 1 && lane.laps.length === 0) {
                       lane.laps.push({ event, lapTime: 0, totalRepTime: 0 });
                    }
                }

                const totalRepTime = now - lane.repStartTime;
                
                const prevEvent = eventIndex > 0 ? pmState.lapSchedule[eventIndex - 1] : {distanceInRep: 0, rep: event.rep};
                const lastLapOfPrevRep = lane.laps.slice().reverse().find(l => l.event.rep === prevEvent.rep && l.event.distanceInRep === prevEvent.distanceInRep);
                const prevRepTime = lastLapOfPrevRep ? lastLapOfPrevRep.totalRepTime : 0;
                const lapTime = totalRepTime - prevRepTime;

                lane.laps.push({ event, lapTime, totalRepTime });
                lane.lastLapTime = lapTime;
                
                if (!event.type.startsWith('START')) {
                    lane.displayFrozen = true;
                    setTimeout(() => { lane.displayFrozen = false; }, 3000);
                }

                if (event.type.startsWith('FINISH') && lane.nextLapIndex < pmState.lapSchedule.length - 1) {
                    lane.paused = true;
                }

                lane.lapStartTime = now;
                lane.nextLapIndex++;
                if (lane.nextLapIndex >= pmState.lapSchedule.length) {
                    lane.running = false;
                    lane.paused = true;
                }
                
                updatePmDisplays();
            };
        });
    }

    function updatePmDisplays() {
        pmState.lanes.forEach(lane => {
            const nextEvent = pmState.lapSchedule[lane.nextLapIndex];
            const btn = document.querySelector(`.pm-lap-btn[data-lane-id="${lane.id}"]`);
            if (!btn) return;
            
            let btnText = `START(${pmState.lapSchedule[0].rep})`;
            let btnColorClass = 'bg-green-500';

            if (lane.nextLapIndex > 0) {
                if (!lane.running && lane.paused) { // Finished
                    btnText = "終了";
                    btnColorClass = 'bg-orange-500';
                    btn.onclick = (e) => {
                        handleButtonInteraction(e);
                        showPmSummary();
                    };
                    btn.nextElementSibling.textContent = '練習終了';
                } else if (nextEvent) {
                    btnText = nextEvent.type;
                    if (btnText.startsWith('START')) {
                        btnColorClass = 'bg-green-500';
                    } else if (btnText.startsWith('FINISH')) {
                        btnColorClass = 'bg-red-500';
                    } else { // PASS
                        btnColorClass = 'bg-gray-700';
                    }
                    
                    const targetInfoEl = document.getElementById(`pm-target-info-${lane.id}`);
                    if (lane.pace > 0) {
                        const targetCumulativeTime = nextEvent.distanceInRep * lane.pace;
                        targetInfoEl.textContent = `目標: ${fmt(targetCumulativeTime)}`;
                    } else {
                        targetInfoEl.textContent = '目標: ---';
                    }
                }
            }
            
            btn.textContent = btnText;
            btn.classList.remove('bg-blue-500', 'bg-green-500', 'bg-red-500', 'bg-gray-700', 'bg-orange-500');
            btn.classList.add(btnColorClass);
            
            const histEl = document.getElementById(`pm-history-${lane.id}`);
            histEl.innerHTML = lane.laps.map(lap => {
                if (lap.event.distanceInRep === 0 && lap.event.type.startsWith('START')) return '';
                return `<div class="hist-line"><span class="font-bold">${lap.event.type}:</span> ${fmt(lap.lapTime)} <span class="text-gray-500">(${fmt(lap.totalRepTime)})</span></div>`;
            }).reverse().join('');
            histEl.scrollTop = 0;
        });

        const firstLane = pmState.lanes[0];
        const currentEvent = pmState.lapSchedule[firstLane.nextLapIndex - 1] || pmState.lapSchedule[0];
        if(currentEvent) document.getElementById('pm-info-bar').textContent = `本数: ${currentEvent.rep} / ${pmState.settings.N}`;
    }

    function tickPacemaker() {
        if (!pmState.lanes) return;
        const now = Date.now();
        pmState.lanes.forEach(lane => {
            if (!lane.running || lane.paused) return;
            const repElapsed = now - lane.repStartTime;
            const lapElapsed = now - lane.lapStartTime;
            const nextEvent = pmState.lapSchedule[lane.nextLapIndex];

            const repTimeEl = document.querySelector(`#pm-lane-${lane.id} .pm-main-time`);
            const lapTimeEl = document.querySelector(`#pm-lane-${lane.id} .pm-lap-live`);
            const laneEl = document.getElementById(`pm-lane-${lane.id}`);
            
            if (lane.displayFrozen) {
                lapTimeEl.textContent = fmt(lane.lastLapTime);
            } else {
                repTimeEl.textContent = fmt(repElapsed);
                lapTimeEl.textContent = fmt(lapElapsed);

                if (lane.pace > 0 && nextEvent) {
                    const targetCumulativeTime = nextEvent.distanceInRep * lane.pace;
                    const diff = targetCumulativeTime - repElapsed;
                    laneEl.classList.remove('frame-warn10', 'frame-warn5', 'frame-bad');
                    if (diff < 0) laneEl.classList.add('frame-bad');
                    else if (diff <= 5000) laneEl.classList.add('frame-warn5');
                    else if (diff <= 10000) laneEl.classList.add('frame-warn10');
                } else {
                    laneEl.classList.remove('frame-warn10', 'frame-warn5', 'frame-bad');
                }
            }
        });
    }

    /* ====== Custom Timer Mode ====== */
    let customSteps = [];
    let customTimerState = {
        running: false, reps: 1, currentRep: 1,
        currentStepIndex: 0, stepStartTime: 0, remainingTime: 0,
    };

    function initCustom() {
        stopCustomTimer();
        customSteps = [ { type: 'WORK', duration: 30 }, { type: 'REST', duration: 10 }];
        document.getElementById('custom-settings').classList.remove('hidden');
        document.getElementById('custom-runner').classList.add('hidden');
        document.getElementById('custom-reps').value = 1;
        renderCustomSteps();
        wireCustomSettings();
    }

    function renderCustomSteps() {
        const container = document.getElementById('custom-steps-container');
        container.innerHTML = customSteps.map((step, index) => `
            <div class="flex items-center gap-2 p-2 bg-gray-100 rounded-lg">
                <span class="font-bold text-gray-600">${index + 1}.</span>
                <select data-index="${index}" class="custom-step-type p-2 border rounded-md flex-grow">
                    <option value="WORK" ${step.type === 'WORK' ? 'selected' : ''}>WORK</option>
                    <option value="REST" ${step.type === 'REST' ? 'selected' : ''}>REST</option>
                </select>
                <input type="number" value="${step.duration}" data-index="${index}" class="custom-step-duration p-2 border rounded-md w-24" placeholder="秒">
                <button data-index="${index}" class="custom-step-delete px-3 py-2 bg-red-500 text-white rounded-md font-bold">×</button>
            </div>
        `).join('');
    }

    function wireCustomSettings() {
        const container = document.getElementById('custom-steps-container');
        container.onchange = (e) => {
            const index = parseInt(e.target.dataset.index);
            if (e.target.classList.contains('custom-step-type')) customSteps[index].type = e.target.value;
            if (e.target.classList.contains('custom-step-duration')) customSteps[index].duration = parseInt(e.target.value) || 0;
        };
        container.onclick = (e) => {
            if (e.target.classList.contains('custom-step-delete')) {
                handleButtonInteraction(e);
                customSteps.splice(parseInt(e.target.dataset.index), 1);
                renderCustomSteps();
            }
        };

        document.getElementById('custom-add-step-btn').onclick = (e) => {
            handleButtonInteraction(e);
            customSteps.push({ type: 'WORK', duration: 30 });
            renderCustomSteps();
        };
        document.getElementById('custom-start-btn').onclick = (e) => { handleButtonInteraction(e); startCustomTimer(); };
        document.getElementById('custom-reset-btn').onclick = (e) => { handleButtonInteraction(e); initCustom(); };
    }

    function startCustomTimer() {
        if (customSteps.length === 0) return;
        customTimerState = {
            running: true,
            reps: parseInt(document.getElementById('custom-reps').value) || 1,
            currentRep: 1, currentStepIndex: 0,
            stepStartTime: Date.now(), remainingTime: customSteps[0].duration,
        };
        document.getElementById('custom-settings').classList.add('hidden');
        document.getElementById('custom-runner').classList.remove('hidden');
        updateCustomRunnerUI();
    }

    function stopCustomTimer() { customTimerState.running = false; }

    function tickCustomTimer() {
        if (!customTimerState.running) return;
        const currentStep = customSteps[customTimerState.currentStepIndex];
        const elapsed = (Date.now() - customTimerState.stepStartTime) / 1000;
        customTimerState.remainingTime = currentStep.duration - elapsed;

        if (customTimerState.remainingTime <= 0) {
            customTimerState.currentStepIndex++;
            if (customTimerState.currentStepIndex >= customSteps.length) {
                customTimerState.currentRep++;
                if (customTimerState.currentRep > customTimerState.reps) {
                    stopCustomTimer(); initCustom(); return;
                }
                customTimerState.currentStepIndex = 0;
            }
            customTimerState.stepStartTime = Date.now();
        }
        updateCustomRunnerUI();
    }

    function updateCustomRunnerUI() {
        const state = customTimerState;
        const runnerEl = document.getElementById('custom-runner');
        if (!state.running || customSteps.length === 0) {
            runnerEl.classList.remove('work-bg', 'rest-bg'); return;
        }
        const currentStep = customSteps[state.currentStepIndex];
        document.getElementById('custom-runner-set-info').textContent = `SET ${state.currentRep} / ${state.reps}`;
        document.getElementById('custom-runner-step-info').textContent = `${currentStep.type} ${state.currentStepIndex + 1} / ${customSteps.length}`;
        document.getElementById('custom-runner-time').textContent = fmtCustom(state.remainingTime);
        runnerEl.classList.toggle('work-bg', currentStep.type === 'WORK');
        runnerEl.classList.toggle('rest-bg', currentStep.type === 'REST');
    }
 
    /* ====== RAF Loop ====== */
    function loop() {
      if (currentScreen === 'split') tickSplit();
      if (currentScreen === 'custom') tickCustomTimer();
      if (currentScreen === 'pm') tickPacemaker();
      requestAnimationFrame(loop);
    }
   
    function recalibratePmLayout(){
        const grid = document.getElementById('pm-runner-grid');
        if (!grid || !pmState.lanes) return;
        const count = pmState.lanes.length;

        if (count <= 2) {
            grid.style.gridTemplateColumns = '1fr';
            grid.style.gridTemplateRows = `repeat(${count}, 1fr)`;
        } else { // 3 or 4
            grid.style.gridTemplateColumns = '1fr 1fr';
            grid.style.gridTemplateRows = '1fr 1fr';
        }
        
        const root = document.documentElement;
        const cards = grid.querySelectorAll('.pm-lane');

        let fontMain, fontLive, btnH, gap = '', padding = '';

        if (count <= 1) {
            fontMain = 'clamp(28px, 8vw, 40px)';
            fontLive = 'clamp(22px, 6vw, 32px)';
            btnH = '76px';
        } else if (count === 2) {
            fontMain = 'clamp(24px, 6.5vw, 32px)';
            fontLive = 'clamp(20px, 5vw, 26px)';
            btnH = '64px';
            gap = '4px';
        } else { // 3 or 4
            fontMain = 'clamp(20px, 5vw, 26px)';
            fontLive = 'clamp(16px, 4vw, 22px)';
            btnH = '48px';
            gap = '2px';
            padding = '6px';
        }
        
        root.style.setProperty('--font-main', fontMain);
        root.style.setProperty('--font-live', fontLive);
        root.style.setProperty('--pm-btn-h', btnH);
        cards.forEach(c => {
            c.style.gap = gap;
            c.style.padding = padding;
        });
    }

    function recalibrateSplitLayout(){
        const grid = document.getElementById('split-grid');
        if (!grid) return;
        const count = watches.length;
        
        if (count <= 2) {
            grid.style.gridTemplateColumns = '1fr';
            grid.style.gridTemplateRows = `repeat(${count}, 1fr)`;
        } else if (count <= 4) {
            grid.style.gridTemplateColumns = '1fr 1fr';
            grid.style.gridTemplateRows = `repeat(${Math.ceil(count / 2)}, 1fr)`;
        } else { // 5 or 6
            grid.style.gridTemplateColumns = '1fr 1fr';
            grid.style.gridTemplateRows = '1fr 1fr 1fr';
        }
        
        const root = document.documentElement;
        const cards = grid.querySelectorAll('.runner-card');
        let fontMain, fontLive, btnH, gap = '', padding = '';

        if (count <= 2) {
            fontMain = 'clamp(28px, 8vw, 40px)';
            fontLive = 'clamp(22px, 6vw, 32px)';
            btnH = '56px';
            gap = '6px';
            padding = '8px';
        } else if (count <= 4) {
            fontMain = 'clamp(24px, 6.5vw, 32px)';
            fontLive = 'clamp(20px, 5vw, 26px)';
            btnH = '48px';
            gap = '4px';
            padding = '8px';
        } else { // 5 or 6
            fontMain = 'clamp(20px, 5vw, 26px)';
            fontLive = 'clamp(16px, 4vw, 22px)';
            btnH = '44px';
            gap = '2px';
            padding = '6px';
        }
        
        root.style.setProperty('--font-main', fontMain);
        root.style.setProperty('--font-live', fontLive);
        root.style.setProperty('--btn-h', btnH);
        cards.forEach(c => {
            c.style.gap = gap;
            c.style.padding = padding;
            // Adjust time display gap for smaller sizes
            if(count > 4) {
                c.querySelector('.runner-main-time').style.marginBottom = '-0.25em';
                c.querySelector('.runner-lap-live').style.marginBottom = '-0.25em';
            } else {
                c.querySelector('.runner-main-time').style.marginBottom = '';
                c.querySelector('.runner-lap-live').style.marginBottom = '';
            }
        });
    }
 
    loop();
  });
  </script>
</body>
</html>

