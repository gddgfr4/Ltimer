<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>多機能トレーニングタイマー Pro — Mobile</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root{
      --approaching-warn-color:#facc15; /* yellow-400 */
      --approaching-imminent-color:#fb923c; /* orange-400 */
      --exceeded-color:#f87171; /* red-400 */
      --work-color:#4ade80; /* green-400 */
      --rest-color:#60a5fa; /* blue-400 */
      /* 動的フォント/サイズ（JSで行数に応じて上書き） */
      --font-main:32px;  /* Total */
      --font-live:28px;  /* Lap live */
      --font-small:16px; /* small text */
      --btn-h:56px;      /* 各カードのボタン高さ(基準) */
      --master-h:64px;   /* 下マスターの高さ */
      --master-btn-py:12px; /* 下マスターのボタン上下padding */
      --master-btn-fs:16px;  /* 下マスターのボタン文字 */
      --pm-btn-h:76px; /* インターバルのボタンを大きく */
    }

    html,body{height:100dvh;margin:0;padding:0;overflow:hidden;background:#e5e7eb;touch-action:manipulation;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif}
    .timer-font{font-variant-numeric:tabular-nums}

    /* 画面: 選択/各モード */
    .screen{position:relative; height:100%; width:100%;}
    .hidden{display:none}

    /* 戻るボタン */
    .back-btn{position:fixed; left:env(safe-area-inset-left,8px); top:calc(env(safe-area-inset-top,8px) + 8px); z-index:60;}
    .back-btn button{width:44px;height:44px;border-radius:9999px}

    /* === Split Mode === */
    .split-wrap{display:flex;flex-direction:column;height:100%;}
    .split-grid{display:grid;flex:1 1 auto;padding:6px;gap:6px;overflow:hidden;}
    .split-card{background:#F9FAFB;border-radius:12px;padding:8px;display:grid;grid-template-columns:1fr 1fr;grid-template-rows:auto auto auto 1fr auto;gap:6px;height:100%;transition:background-color .2s}

    .split-card-header{grid-column:1/-1;display:grid;grid-template-columns:1fr minmax(86px,42%);gap:6px;align-items:center}
    .split-name-input{min-width:0;text-align:left}
    .target-lap-input{min-width:0;text-align:center;padding:4px 6px}

    .split-main-time{grid-column:1/-1;font-size:var(--font-main);font-weight:800}
    .split-lap-live{grid-column:1/-1;font-size:var(--font-live);font-weight:800;border-radius:8px;padding:4px 6px}
    /* 枠全体に色付けするためのクラス（10秒前までは無色）*/
    .frame-warn10{background:#fef3c7!important} /* amber-100 */
    .frame-warn5 {background:#ffedd5!important} /* orange-100 */
    .frame-bad   {background:#fee2e2!important} /* red-100 */

    .split-lap-history{grid-column:1/-1;overflow-y:auto;min-height:1.6em;background:rgba(229,231,235,.8);border-radius:8px;padding:4px 6px;line-height:1.2;font-size:clamp(11px,2.8vw,13px)}
    .split-lap-history .hist-line{margin-bottom:2px}
    .split-lap-history .hist-n{margin-right:4px;font-weight:700}
    .split-lap-history .hist-cum{margin-left:4px;color:#6b7280}

    .split-actions{grid-column:1/-1;display:grid;grid-template-columns:1fr 1.6fr;gap:6px} /* 左:START/STOP 右:LAP(横幅大) */
    .btn-lap,.btn-start{height:var(--btn-h)} /* 同じ縦幅 */

    .split-master{height:var(--master-h);background:#1f2937;color:white;display:flex;gap:8px;align-items:center;justify-content:space-around;padding:8px}
    .split-master .btn{padding-top:var(--master-btn-py);padding-bottom:var(--master-btn-py);font-size:var(--master-btn-fs)}

    /* === Pacemaker === */
    .pm-grid{display:grid;grid-auto-rows:minmax(180px,1fr);gap:6px;height:100%;padding:6px;overflow:hidden}
    .pm-lane{display:grid;grid-template-columns:2fr 3fr;grid-template-rows:1fr 1fr 1fr;background:#fff;border-radius:12px;padding:8px;transition:background-color .2s}
    .pm-lane-main{grid-row:1/-1;display:flex;flex-direction:column;align-items:center;justify-content:center;border-right:1px solid #e5e7eb}
    .pm-lane-history{font-size:12px;display:flex;flex-wrap:wrap;align-content:flex-start;gap:4px}
    .pm-lane-rest{background:var(--rest-color)!important;color:#fff}
    .pm-lap-btn{width:100%;height:var(--pm-btn-h);font-size:clamp(18px,5vw,24px);padding:12px 16px;border-radius:14px}

    /* インターバル色付け（初期ロジック復元） */
    .approaching-warn{ background-color: var(--approaching-warn-color)!important; }
    .approaching-imminent{ background-color: var(--approaching-imminent-color)!important; }
    .exceeded{ background-color: var(--exceeded-color)!important; color:#fff!important; }
    .exceeded div,.exceeded span,.exceeded p,.exceeded input,.exceeded label{ color:#fff!important; }

    /* === Custom Timer === */
    .custom-runner{transition:background-color .3s}
    .work-bg{background:var(--work-color)}
    .rest-bg{background:var(--rest-color);color:#fff}

    /* Summary modal */
    .summary-modal{position:fixed;inset:0;background:rgba(0,0,0,.6);display:flex;justify-content:center;align-items:center;z-index:70;padding:16px}
    .summary-content{background:#fff;border-radius:12px;padding:16px;width:100%;max-width:680px;max-height:90vh;overflow:auto}
    .summary-table{width:100%;border-collapse:collapse;margin-top:12px}
    .summary-table th,.summary-table td{border:1px solid #d1d5db;padding:6px;text-align:center}
    .summary-table th{background:#f3f4f6}

    /* Help modal */
    .help-modal{position:fixed;inset:0;background:rgba(0,0,0,.6);display:flex;justify-content:center;align-items:center;z-index:80;padding:16px}
    .help-content{background:#fff;border-radius:12px;padding:16px;width:100%;max-width:680px;max-height:90vh;overflow:auto}
    .help-content h3{font-weight:700;margin-top:12px}
    .help-content ul{list-style:disc;padding-left:1.25rem}

    @media (max-width:430px){
      .split-card{gap:4px;padding:6px}
      .split-card-header{grid-template-columns:1fr minmax(80px,48%)}
    }
  </style>
</head>
<body>
  <!-- モード選択画面 -->
  <section id="screen-chooser" class="screen flex flex-col items-center justify-center gap-5 p-6">
    <h1 class="text-2xl font-bold mb-2">モードを選択</h1>
    <div class="grid grid-cols-1 gap-3 w-full max-w-sm">
      <div class="grid grid-cols-3 gap-2">
        <button id="choose-split" class="col-span-2 py-4 text-xl font-bold text-white bg-indigo-600 rounded-xl shadow">ペース走</button>
        <button id="help-split" class="py-2 text-sm font-bold text-indigo-700 bg-indigo-50 rounded-xl border border-indigo-200">説明</button>
      </div>
      <div class="grid grid-cols-3 gap-2">
        <button id="choose-pm" class="col-span-2 py-4 text-xl font-bold text-white bg-green-600 rounded-xl shadow">インターバル</button>
        <button id="help-pm" class="py-2 text-sm font-bold text-green-700 bg-green-50 rounded-xl border border-green-200">説明</button>
      </div>
      <div class="grid grid-cols-3 gap-2">
        <button id="choose-custom" class="col-span-2 py-4 text-xl font-bold text-white bg-gray-800 rounded-xl shadow">タイマー</button>
        <button id="help-custom" class="py-2 text-sm font-bold text-gray-700 bg-gray-50 rounded-xl border border-gray-200">説明</button>
      </div>
    </div>
  </section>

  <!-- 戻るボタン（モード時のみ表示） -->
  <div id="back" class="back-btn hidden">
    <button class="bg-white shadow text-xl" aria-label="戻る">←</button>
  </div>

  <!-- Split -->
  <section id="screen-split" class="screen hidden">
    <div class="split-wrap">
      <div id="split-grid" class="split-grid"></div>
      <div id="split-master" class="split-master">
        <button data-action="add" class="w-12 h-12 rounded-full bg-blue-500 text-white text-2xl">+</button>
        <button data-action="remove" class="w-12 h-12 rounded-full bg-gray-500 text-white text-2xl">−</button>
        <button data-action="start-all" class="btn px-4 bg-green-500 rounded font-bold">START ALL</button>
        <button data-action="stop-all"  class="btn px-4 bg-red-500 rounded font-bold">STOP ALL</button>
        <button data-action="reset-all" class="btn px-4 bg-orange-500 rounded font-bold">RESET & REVIEW</button>
      </div>
    </div>
  </section>

  <!-- Pacemaker -->
  <section id="screen-pm" class="screen hidden">
    <div id="pm-settings" class="p-4 space-y-3">
      <h2 class="text-xl font-bold text-center">インターバル設定</h2>
      <div class="grid grid-cols-2 gap-3">
        <input id="pm-distance" type="number" placeholder="距離(m)" class="p-2 border rounded-md text-lg">
        <input id="pm-lap-distance" type="number" placeholder="ラップ距離(m)" value="400" class="p-2 border rounded-md text-lg">
        <input id="pm-reps" type="number" placeholder="本数" class="p-2 border rounded-md text-lg">
        <div>
          <button id="pm-lane-minus" class="px-3 py-2 border rounded-l-md">-</button>
          <span id="pm-lane-count" class="px-4 py-2 border-t border-b">1レーン</span>
          <button id="pm-lane-plus" class="px-3 py-2 border rounded-r-md">+</button>
        </div>
        <div class="col-span-2 flex items-center gap-2">
          <input id="pm-rest-dist" type="number" placeholder="レスト距離(m)" class="p-2 border rounded-md text-lg w-full">
          <input type="checkbox" id="pm-return-to-start" class="h-5 w-5 ml-2"><label for="pm-return-to-start">開始点へ</label>
        </div>
      </div>
      <div id="pm-lane-targets" class="space-y-2"></div>
      <button id="pm-start-btn" class="w-full mt-1 py-3 text-2xl font-bold text-white bg-green-500 rounded-lg shadow-lg">練習開始</button>
    </div>
    <div id="pm-runner" class="hidden h-full">
      <div id="pm-runner-grid" class="pm-grid"></div>
    </div>
  </section>

  <!-- Custom Timer -->
  <section id="screen-custom" class="screen hidden">
    <div id="custom-settings" class="p-4">
      <h2 class="text-xl font-bold text-center mb-4">タイマー設定</h2>
      <div id="custom-steps-container" class="space-y-2"></div>
      <button id="custom-add-step-btn" class="w-full mt-4 py-2 text-lg text-indigo-600 border-2 border-indigo-600 rounded-lg">ステップを追加</button>
      <div class="mt-4">
        <label for="custom-reps" class="font-bold">セット数:</label>
        <input id="custom-reps" type="number" value="1" class="w-full p-2 border rounded-md text-lg mt-1">
      </div>
      <button id="custom-start-btn" class="w-full mt-4 py-3 text-2xl font-bold text-white bg-green-500 rounded-lg shadow-lg">START</button>
    </div>
    <div id="custom-runner" class="hidden h-full flex flex-col justify-between items-center text-center p-4 custom-runner">
      <div>
        <div id="custom-runner-set-info" class="text-3xl font-bold">SET 1 / 1</div>
        <div id="custom-runner-step-info" class="text-2xl">WORK 1 / 2</div>
      </div>
      <div id="custom-runner-time" class="text-9xl font-extrabold timer-font">00:30</div>
      <div class="w-full"><button id="custom-reset-btn" class="w-full py-4 text-2xl font-bold text-gray-700 bg-gray-200 rounded-lg">RESET</button></div>
    </div>
  </section>

  <!-- Summary Modal -->
  <div id="summary" class="summary-modal hidden">
    <div class="summary-content">
      <h2 id="summary-title" class="text-2xl font-bold text-center">練習結果</h2>
      <div id="summary-table"></div>
      <div class="flex gap-4 mt-6">
        <button id="summary-csv" class="w-full py-3 text-lg font-bold text-white bg-green-600 rounded-lg">CSVダウンロード</button>
        <button id="summary-close" class="w-full py-3 text-lg font-bold text-gray-700 bg-gray-200 rounded-lg">閉じる</button>
      </div>
    </div>
  </div>

  <!-- Help Modal -->
  <div id="help" class="help-modal hidden">
    <div class="help-content">
      <div class="flex items-center justify-between">
        <h2 id="help-title" class="text-2xl font-bold">使い方</h2>
        <button id="help-close" class="px-3 py-1 bg-gray-200 rounded">閉じる</button>
      </div>
      <div id="help-body" class="mt-3 text-sm leading-relaxed"></div>
    </div>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    /* ====== Screen Navigation ====== */
    const screens = {
      chooser: document.getElementById('screen-chooser'),
      split:   document.getElementById('screen-split'),
      pm:      document.getElementById('screen-pm'),
      custom:  document.getElementById('screen-custom'),
    };
    const backWrap = document.getElementById('back');
    let current = 'chooser';

    function show(screen){
      Object.values(screens).forEach(el=>el.classList.add('hidden'));
      screens[screen].classList.remove('hidden');
      current = screen;
      backWrap.classList.toggle('hidden', screen==='chooser');
      if(screen==='split') recalibrateSplitLayout();
    }

    document.getElementById('choose-split').onclick = ()=>{ initSplit(); show('split'); };
    document.getElementById('choose-pm').onclick    = ()=>{ initPacemaker(); show('pm'); };
    document.getElementById('choose-custom').onclick= ()=>{ initCustom(); show('custom'); };
    backWrap.querySelector('button').onclick = ()=>{ show('chooser'); };

    /* ====== Help ====== */
    const help = {
      el: document.getElementById('help'),
      title: document.getElementById('help-title'),
      body: document.getElementById('help-body'),
      close: document.getElementById('help-close')
    };

    const helpContent = {
      split: `
        <p class="text-base">ペース走は複数の個別ストップウォッチです。</p>
        <h3>設定の仕方</h3>
        <ul>
          <li>各カード上部の「目標(sec)」に1ラップ目標を秒で入力。</li>
          <li>下マスターの + / − で時計を追加/削除（最大6）。</li>
          <li>RESET & REVIEW で振り返り表を表示し、全リセット。</li>
        </ul>
        <h3>色付けの原理</h3>
        <ul>
          <li>目標未設定: 無色。</li>
          <li>目標まで残り ≤10s: カード全体が淡い黄（注意）。</li>
          <li>残り ≤5s: 橙（かなり接近）。</li>
          <li>超過: 赤（超過）。</li>
        </ul>
        <h3>特殊な動き</h3>
        <ul>
          <li>LAP後はそのラップを3秒間固定表示。</li>
          <li>START ALL / STOP ALL で全体制御。</li>
        </ul>
      `,
      pm: `
        <p class="text-base">インターバルは距離×本数の練習で、レーンごとに目標を管理します。</p>
        <h3>設定の仕方</h3>
        <ul>
          <li>距離(m)、本数、レーン数（±）を設定。</li>
          <li>各レーンの「分」「秒」に1本の目標合計タイムを入力。</li>
          <li>レスト距離を指定、または「開始点へ」で自動復帰（<code>400 - (距離 % 400)</code>）。</li>
        </ul>
        <h3>色付けの原理</h3>
        <ul>
          <li>次の通過目標に対し、残り ≤10s: 黄、≤5s: 橙、超過: 赤。</li>
        </ul>
        <h3>操作</h3>
        <ul>
          <li>START で1本開始、LAPで分割、NEXT REP で次の本へ。</li>
          <li>全員終了で自動的に振り返り表を表示。</li>
        </ul>
      `,
      custom: `
        <p class="text-base">任意のWORK/RESTを並べてセットを回します。</p>
        <h3>設定の仕方</h3>
        <ul>
          <li>ステップを追加し、各秒数とタイプを指定。</li>
          <li>セット数を入力し、START。</li>
        </ul>
        <h3>色付け</h3>
        <ul>
          <li>WORK: 緑背景、REST: 青背景。</li>
        </ul>
      `
    };

    function openHelp(mode){
      help.title.textContent = ({split:'ペース走の説明', pm:'インターバルの説明', custom:'タイマーの説明'})[mode]||'説明';
      help.body.innerHTML = helpContent[mode]||'';
      help.el.classList.remove('hidden');
    }
    function closeHelp(){ help.el.classList.add('hidden'); }
    help.close.onclick = closeHelp;
    document.getElementById('help-split').onclick = ()=>openHelp('split');
    document.getElementById('help-pm').onclick    = ()=>openHelp('pm');
    document.getElementById('help-custom').onclick= ()=>openHelp('custom');

    /* ====== Audio ====== */
    let audioCtx; function initAudio(){ if(!audioCtx){ audioCtx=new (window.AudioContext||window.webkitAudioContext)(); } }
    document.body.addEventListener('click', initAudio, {once:true});
    function beep(f,ms){ if(!audioCtx) return; const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.connect(g); g.connect(audioCtx.destination); o.type='sine'; o.frequency.value=f; g.gain.value=0.1; o.start(); o.stop(audioCtx.currentTime+ms/1000); }

    /* ====== Utils ====== */
    const fmt=(ms,h=true)=>{ if(isNaN(ms)||ms<0) ms=0; const d=new Date(ms); const m=String(d.getUTCMinutes()); const s=String(d.getUTCSeconds()).padStart(2,'0'); if(!h) return `${m}:${s}`; const hnd=String(Math.floor(d.getUTCMilliseconds()/10)).padStart(2,'0'); return `${m}:${s}.${hnd}`; };

    /* ====== Summary ====== */
    const summary = {
      modal: document.getElementById('summary'),
      title: document.getElementById('summary-title'),
      table: document.getElementById('summary-table'),
      csv:   document.getElementById('summary-csv'),
      close: document.getElementById('summary-close'),
      data:  null,
      mode:  null
    };

    function openSummary(){ summary.modal.classList.remove('hidden'); }
    function closeSummary(){ summary.modal.classList.add('hidden'); }
    summary.close.onclick = closeSummary;

    function buildSplitSummary(data){
      summary.title.textContent = 'ペース走結果';
      const rows = data.map(sw=>{
        const laps = sw.laps.map((l,i)=> `${i+1}: ${fmt(l)}`).join('<br>');
        return `<tr><td>${sw.name}</td><td>${fmt(sw.elapsed)}</td><td class="text-left">${laps}</td></tr>`;
      }).join('');
      summary.table.innerHTML = `<table class="summary-table"><thead><tr><th>名前</th><th>Total</th><th>Laps</th></tr></thead><tbody>${rows}</tbody></table>`;
    }

    function buildPmSummary(pm){
      const {settings, lanes} = pm;
      summary.title.textContent = `インターバル結果 (${settings.distance}m × ${settings.reps})`;
      let html = '';
      for(let rep=1; rep<=settings.reps; rep++){
        const headerSplits = (lanes[0]?.fullLapHistory||[]).filter(h=>h.rep===rep).map(h=>h.dist);
        html += `<h3 class="mt-4 font-bold">${rep}本目</h3>`;
        html += `<table class="summary-table"><thead><tr><th>名前</th><th>Total</th>${headerSplits.map(d=>`<th>${d}m</th>`).join('')}</tr></thead><tbody>`;
        lanes.forEach(l=>{
          const repSplits = l.fullLapHistory.filter(h=>h.rep===rep);
          if(repSplits.length===0) return;
          const total = repSplits.at(-1)?.totalTime ?? 0;
          html += `<tr><td>${l.name}</td><td>${fmt(total)}</td>${repSplits.map(s=>`<td>${fmt(s.lapTime)}</td>`).join('')}</tr>`;
        });
        html += `</tbody></table>`;
      }
      summary.table.innerHTML = html;
    }

    summary.csv.onclick = ()=>{
      if(!summary.data) return;
      let tsv='';
      if(summary.mode==='split'){
        tsv += ['Name','Total','Laps'].join('\t')+'\n';
        summary.data.forEach(sw=>{
          tsv += [sw.name, fmt(sw.elapsed), sw.laps.map(l=>fmt(l)).join(' ')].join('\t')+'\n';
        });
      } else if(summary.mode==='pm'){
        const {settings, lanes} = summary.data;
        for(let rep=1; rep<=settings.reps; rep++){
          const headerSplits = (lanes[0]?.fullLapHistory||[]).filter(h=>h.rep===rep).map(h=>h.dist);
          let header = ['Rep','Name','Total', ...headerSplits.map((d,i)=>`Lap ${i+1} (${d}m)`)].join('\t');
          tsv += header+'\n';
          lanes.forEach(l=>{
            const repSplits = l.fullLapHistory.filter(h=>h.rep===rep);
            if(repSplits.length===0) return;
            const total = repSplits.at(-1)?.totalTime ?? 0;
            const row = [rep, l.name, fmt(total), ...repSplits.map(s=>fmt(s.lapTime))].join('\t');
            tsv += row+'\n';
          });
        }
      }
      const blob = new Blob([new Uint8Array([0xEF,0xBB,0xBF]), tsv], {type:'text/tab-separated-values;charset=utf-8'});
      const url = URL.createObjectURL(blob); const a=document.createElement('a');
      a.href=url; a.download='timer_results.tsv'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    };

    /* ====== Split Mode ====== */
    let watches=[]; let rafId;
    const splitGrid = document.getElementById('split-grid');
    const splitMaster = document.getElementById('split-master');

    function initSplit(){
      watches=[{id:0,name:'時計 1',running:false,start:0,elapsed:0,lastLap:0,laps:[],target:0,freezeUntil:0,frozenLap:0,pendingLast:null}];
      renderSplit();
    }

    // 列/行・フォント/ボタン/マスターを再計算（スマホ最適化）
    function recalibrateSplitLayout(){
      const count=watches.length;
      const cols=(count>=2)?2:1; // 2台以上は2列
      splitGrid.style.gridTemplateColumns = cols===2 ? '1fr 1fr' : '1fr';

      const rows=Math.ceil(count/cols);
      const st=getComputedStyle(splitGrid);
      const padV=parseFloat(st.paddingTop)+parseFloat(st.paddingBottom);
      const gap=parseFloat(st.gap)||6;
      const avail = screens.split.clientHeight - splitMaster.offsetHeight - padV;
      const rowH = Math.max(150, Math.floor((avail - (rows-1)*gap)/rows));
      splitGrid.style.gridAutoRows = rowH+'px';

      // 行数に応じ可変（5台=2列3行でコンパクトに）
      let main=32, live=28, small=16;
      let btnH=56, masterH=64, masterBtnPy=12, masterBtnFs=16;
      if(rows>=3){
        main=24; live=20; small=14;
        btnH=44; masterH=52; masterBtnPy=6; masterBtnFs=14;
      }else if(rows===2){
        main=30; live=26; small=15;
        btnH=52; masterH=60; masterBtnPy=10; masterBtnFs=15;
      }
      const root=document.documentElement;
      root.style.setProperty('--font-main',  main+'px');
      root.style.setProperty('--font-live',  live+'px');
      root.style.setProperty('--font-small', small+'px');
      root.style.setProperty('--btn-h', btnH+'px');
      root.style.setProperty('--master-h', masterH+'px');
      root.style.setProperty('--master-btn-py', masterBtnPy+'px');
      root.style.setProperty('--master-btn-fs', masterBtnFs+'px');
    }
    window.addEventListener('resize', ()=>{ if(current==='split') recalibrateSplitLayout(); });

    function renderSplit(){
      splitGrid.innerHTML = watches.map(sw=>{
        let cum=0; const hist = sw.laps.map((lap,i)=>{cum+=lap; return {n:i+1,lap,cum};}).slice().reverse()
          .map(h=>`<div class="hist-line"><span class="hist-n">${h.n}</span><span class="hist-lap">${fmt(h.lap)}</span><span class="hist-cum">(${fmt(h.cum)})</span></div>`).join('') || '<p class="text-xs text-center text-gray-400">ラップ履歴</p>';
        return `<div class="split-card" id="w-${sw.id}">
          <div class="split-card-header">
            <input type="text" value="${sw.name}" data-id="${sw.id}" class="split-name-input p-1 bg-gray-100 rounded font-bold">
            <input type="number" data-id="${sw.id}" placeholder="目標(sec)" value="${sw.target>0?sw.target:''}" class="target-lap-input border-2 rounded">
          </div>
          <div class="split-main-time timer-font text-gray-900">${fmt(sw.elapsed)}</div>
          <div class="split-lap-live timer-font" id="live-${sw.id}">${fmt(sw.elapsed - sw.lastLap)}</div>
          <div class="split-lap-history">${hist}</div>
          <div class="split-actions">
            <button data-id="${sw.id}" data-action="start" class="btn-start text-white font-bold rounded ${sw.running?'bg-red-500':'bg-green-500'}">${sw.running?'STOP':'START'}</button>
            <button data-id="${sw.id}" data-action="lap" class="btn-lap text-white font-bold rounded bg-gray-700">LAP (${sw.laps.length+1})</button>
          </div>
        </div>`; }).join('');
      recalibrateSplitLayout();
      wireSplit();
    }

    function wireSplit(){
      // 入力
      splitGrid.querySelectorAll('.target-lap-input,.split-name-input').forEach(el=>{
        el.oninput=(e)=>{
          const id=+e.target.dataset.id; const sw=watches.find(w=>w.id===id); if(!sw) return;
          if(e.target.classList.contains('target-lap-input')) sw.target=parseFloat(e.target.value)||0; else sw.name=e.target.value;
        }
      });
      // ボタン
      splitGrid.querySelectorAll('button').forEach(btn=>{
        btn.onclick=(e)=>{
          const id=+e.currentTarget.dataset.id; const action=e.currentTarget.dataset.action; const sw=watches.find(w=>w.id===id); if(!sw) return;
          if(action==='start'){ sw.running=!sw.running; if(sw.running) sw.start=Date.now()-sw.elapsed; renderSplit(); }
          if(action==='lap' && sw.running){ const now=Date.now(); const lap=sw.elapsed - sw.lastLap; sw.laps.push(lap); sw.frozenLap=lap; sw.freezeUntil=now+3000; sw.pendingLast=sw.elapsed; renderSplit(); }
        }
      });
      // マスター
      splitMaster.querySelectorAll('button').forEach(b=>{
        b.onclick=(e)=>{
          const a=e.currentTarget.dataset.action; const any=watches.some(w=>w.running);
          if(a==='add' && watches.length<6){ const nid=(watches.at(-1)?.id??-1)+1; watches.push({id:nid,name:`時計 ${nid+1}`,running:false,start:0,elapsed:0,lastLap:0,laps:[],target:0,freezeUntil:0,frozenLap:0,pendingLast:null}); renderSplit(); }
          if(a==='remove' && watches.length>1){ watches.pop(); renderSplit(); }
          if(a==='start-all'){ const now=Date.now(); watches.forEach(w=>{ if(!w.running){ w.running=true; w.start=now-w.elapsed; }}); renderSplit(); }
          if(a==='stop-all'){ watches.forEach(w=>w.running=false); renderSplit(); }
          if(a==='reset-all' && !any){
            summary.mode='split';
            summary.data = watches.map(w=>({name:w.name, elapsed:w.elapsed, laps:[...w.laps]}));
            buildSplitSummary(summary.data);
            openSummary();
            initSplit();
          }
        }
      });
    }

    /* Splitの毎フレーム更新（色は "10秒前まで無色" で枠全体に付与） */
    function tickSplit(){
      const now=Date.now();
      watches.forEach(sw=>{
        if(!sw.running) return; sw.elapsed = now - sw.start;
        const card=document.getElementById('w-'+sw.id); if(!card) return;
        card.querySelector('.split-main-time').textContent = fmt(sw.elapsed);
        let showMs;
        if(sw.freezeUntil && sw.freezeUntil>now){ showMs=sw.frozenLap; }
        else { if(sw.pendingLast!=null){ sw.lastLap=sw.pendingLast; sw.pendingLast=null; sw.frozenLap=0; sw.freezeUntil=0; } showMs=sw.elapsed - sw.lastLap; }
        const live=document.getElementById('live-'+sw.id);
        if(live){ live.textContent=fmt(showMs); }

        card.classList.remove('frame-warn10','frame-warn5','frame-bad');
        if(sw.target>0){
          const tgt=sw.target*1000; const rem=tgt-showMs;
          if(showMs>tgt)          card.classList.add('frame-bad');
          else if(rem<=5000)      card.classList.add('frame-warn5');
          else if(rem<=10000)     card.classList.add('frame-warn10');
        }
      });
    }

    /* ====== Pacemaker（初期版ロジックに戻す） ====== */
    let pmState = {};
    const pmSettings = document.getElementById('pm-settings');
    const pmRunner   = document.getElementById('pm-runner');
    const pmGrid     = document.getElementById('pm-runner-grid');

    function initPacemaker(){ pmState = { status:'idle', settings:{ lanes:1 } }; renderPmSettings(); }

    function renderPmSettings(){
      pmRunner.classList.add('hidden');
      pmSettings.classList.remove('hidden');
      document.getElementById('pm-lane-count').textContent = `${pmState.settings.lanes} レーン`;
      const trg = document.getElementById('pm-lane-targets');
      trg.innerHTML = Array.from({length:pmState.settings.lanes},(_,i)=>
        `<div class="flex items-center gap-2">
          <input type="text" placeholder="レーン ${i+1} 名前" class="pm-lane-name p-2 border rounded-md w-1/3" data-lane="${i}">
          <input type="number" placeholder="分" class="pm-target-min w-1/3 p-2 border rounded-md" data-lane="${i}">
          <input type="number" placeholder="秒" class="pm-target-sec w-1/3 p-2 border rounded-md" data-lane="${i}">
        </div>`
      ).join('');
    }

    document.getElementById('pm-lane-plus').onclick = ()=>{ if(pmState.settings.lanes<4){ pmState.settings.lanes++; renderPmSettings(); } };
    document.getElementById('pm-lane-minus').onclick= ()=>{ if(pmState.settings.lanes>1){ pmState.settings.lanes--; renderPmSettings(); } };
    document.getElementById('pm-return-to-start').addEventListener('change', (e)=>{
      const distInput = document.getElementById('pm-rest-dist');
      distInput.disabled = e.target.checked;
      distInput.placeholder = e.target.checked ? '自動計算' : 'レスト距離(m)';
      if(e.target.checked) distInput.value='';
    });
    document.getElementById('pm-start-btn').onclick = startPacemakerSession;
    function startPacemakerSession() {
      // 1. ユーザー入力値を取得
      const distance = parseInt(document.getElementById('pm-distance').value) || 0;
      const lapDistance = parseInt(document.getElementById('pm-lap-distance').value) || 400;
      const reps = parseInt(document.getElementById('pm-reps').value) || 1;
      const returnToStart = document.getElementById('pm-return-to-start').checked;
      const restDist = parseInt(document.getElementById('pm-rest-dist').value) || 0;

      if (distance <= 0 || lapDistance <= 0) {
        alert('有効な距離を入力してください');
        return;
      }
      
      const mod = (n, m) => ((n % m) + m) % m;

      // 2. 各本のスタート位置を計算
      const repStartOffsets = new Array(reps);
      if (returnToStart) {
        // 「開始点へ」ONの場合：最終ゴールから逆算する
        let lastRepStartPos = mod(lapDistance - distance, lapDistance);
        let currentPos = lastRepStartPos;
        for (let i = reps - 2; i >= 0; i--) {
          const prevGoalPos = mod(currentPos - restDist, lapDistance);
          currentPos = mod(prevGoalPos - distance, lapDistance);
        }
        repStartOffsets[0] = currentPos; // 1本目のスタート位置が確定
        
        // 2本目以降のスタート位置を順方向に計算
        for (let i = 1; i < reps; i++) {
            const prevGoalPos = mod(repStartOffsets[i-1] + distance, lapDistance);
            repStartOffsets[i] = mod(prevGoalPos + restDist, lapDistance);
        }

      } else {
        // OFFの場合：0m地点から順方向に計算
        repStartOffsets[0] = 0;
        for (let i = 1; i < reps; i++) {
          const prevGoalPos = mod(repStartOffsets[i-1] + distance, lapDistance);
          repStartOffsets[i] = mod(prevGoalPos + restDist, lapDistance);
        }
      }

      // 3. stateを構築
      const settings = { distance, reps, restDist, returnToStart, lapDistance, repStartOffsets, lanes: [] };
      for (let i = 0; i < pmState.settings.lanes; i++) {
        const name = document.querySelector(`.pm-lane-name[data-lane="${i}"]`).value || `レーン ${i + 1}`;
        const min = parseInt(document.querySelector(`.pm-target-min[data-lane="${i}"]`).value) || 0;
        const sec = parseInt(document.querySelector(`.pm-target-sec[data-lane="${i}"]`).value) || 0;
        settings.lanes.push({ name, targetSec: min * 60 + sec });
      }
      
      pmState = {
        status: 'ready', settings,
        lanes: settings.lanes.map((laneSetting, i) => ({
          id: i, name: laneSetting.name, status: 'ready', startTime: 0, repStartTime: 0, elapsed: 0,
          lapCount: 0, lastLapTime: 0, fullLapHistory: [], totalTime: 0, currentRep: 1,
          targetSplits: calculateTargetSplits(settings, laneSetting.targetSec, settings.repStartOffsets[0]),
          targetSec: laneSetting.targetSec,
        }))
      };

      pmSettings.classList.add('hidden');
      pmRunner.classList.remove('hidden');
      renderPacemaker();
    }
    function calculateTargetSplits(settings, targetSec, startOffset) {
      const { distance, lapDistance } = settings;
      if (distance <= 0) return [];
      
      const workPace = targetSec > 0 ? (targetSec * 1000) / distance : Infinity;
      const mod = (n, m) => ((n % m) + m) % m;

      let currentRunDist = 0;
      const splits = [];

      while (currentRunDist < distance) {
        // 現在位置から次の周回ラインまでの距離を計算
        let distToNextLapLine = lapDistance - mod(startOffset + currentRunDist, lapDistance);
        if (distToNextLapLine === 0) distToNextLapLine = lapDistance;

        let lapDist = distToNextLapLine;
        // 本数のゴールが周回ラインより手前なら、ゴールまでの距離をラップ距離とする
        if (currentRunDist + lapDist > distance) {
          lapDist = distance - currentRunDist;
        }
        
        currentRunDist += lapDist;
        const targetTime = workPace * currentRunDist;
        splits.push({ dist: currentRunDist, targetTime });
      }
      return splits;
    }
   
    function renderPacemaker(){
      if(pmState.status==='idle' || pmState.status==='finished' || !pmState.lanes) return;
      pmGrid.innerHTML = pmState.lanes.map(lane=>{
        const nextSplit = lane.targetSplits[lane.lapCount];
        const isFinished = lane.status==='finished';
        const isResting  = lane.status==='resting';
        const lapHistoryHtml = lane.fullLapHistory.filter(l=>l.rep===lane.currentRep).map(l=>`<span>${l.dist}m: ${fmt(l.lapTime)}</span>`).join(', ');
        return `<div class="pm-lane ${isResting?'pm-lane-rest':''}" id="lane-${lane.id}">
          <div class="pm-lane-main">
            <div class="text-sm font-semibold">${lane.name} (${lane.currentRep}/${pmState.settings.reps})</div>
            <div class="text-3xl font-bold timer-font">${fmt(lane.elapsed)}</div>
            <div class="text-xl font-bold timer-font text-gray-500">Lap: ${fmt(lane.elapsed - lane.lastLapTime)}</div>
          </div>
          <div class="pm-lane-split flex items-center justify-center text-center">
            ${isFinished ? `<div class="font-bold text-green-600">SESSION FINISHED!</div>`
              : isResting ? `<div class="font-bold">REP ${lane.currentRep-1} FINISHED<br>${fmt(lane.totalTime)}</div>`
              : `<div>
                  <div>Next: ${nextSplit?.dist||'-'}m</div>
                  ${nextSplit?.targetTime>0 ? `<div>Target: ${fmt(nextSplit.targetTime)}</div>` : ''}
                </div>`}
          </div>
          <div class="pm-lane-history">${lapHistoryHtml}</div>
          <div class="pm-lane-lap flex items-center justify-center">
            <button data-lane="${lane.id}" class="pm-lap-btn text-white font-bold ${isFinished ? 'bg-gray-400' : (lane.status==='ready'||lane.status==='resting' ? 'bg-green-500' : 'bg-indigo-500')}" ${isFinished?'disabled':''}>
              ${lane.status==='ready' ? 'START' : (lane.status==='resting' ? 'NEXT REP' : 'LAP')}
            </button>
          </div>
        </div>`;
      }).join('');

      pmGrid.querySelectorAll('.pm-lap-btn').forEach(btn=>{
        btn.onclick=(e)=>{
          const laneId = +e.currentTarget.dataset.lane; handlePmLap(laneId);
        };
      });
    }

    function updatePacemaker(){
      if((pmState.status==='running' || pmState.status==='ready') && pmState.lanes){
        const now = Date.now();
        pmState.lanes.forEach(lane=>{
          if(lane.status==='running'){
            lane.elapsed = now - lane.startTime;
            const card = document.getElementById(`lane-${lane.id}`);
            if(!card) return;
            card.querySelector('.text-3xl').textContent = fmt(lane.elapsed);
            card.querySelector('.text-xl').textContent = `Lap: ${fmt(lane.elapsed - lane.lastLapTime)}`;
            const nextSplit = lane.targetSplits[lane.lapCount];
            if(nextSplit && nextSplit.targetTime>0){
              const elapsedInRep = lane.elapsed;
              const remainingMs = nextSplit.targetTime - elapsedInRep;
              card.classList.remove('approaching-warn','approaching-imminent','exceeded');
              if(elapsedInRep > nextSplit.targetTime) card.classList.add('exceeded');
              else if(remainingMs <= 5000)            card.classList.add('approaching-imminent');
              else if(remainingMs <= 10000)           card.classList.add('approaching-warn');
            }
          }
        });
      }
    }

    function handlePmLap(laneId){
      if(!pmState.lanes) return;
      const lane = pmState.lanes.find(l=>l.id===laneId);
      if(!lane || lane.status==='finished') return;
      const now = Date.now();

      if(lane.status==='ready' || lane.status==='resting'){
        if(lane.status === 'resting'){
          lane.currentRep++;
          // ▼変更: 次のレップのスタート位置を使ってスプリットを再計算
          const nextRepOffset = pmState.settings.repStartOffsets[lane.currentRep - 1];
          lane.targetSplits = calculateTargetSplits(pmState.settings, lane.targetSec, nextRepOffset);
        }
        pmState.status='running';
        lane.status='running';
        lane.startTime = now;
        lane.repStartTime = now;
        lane.elapsed = 0;
        lane.lastLapTime = 0;
        lane.lapCount = 0;
        lane.lapHistory = [];
      } else if(lane.status==='running'){
        const split = lane.targetSplits[lane.lapCount];
        if(!split) return;
        const lapTime = lane.elapsed - lane.lastLapTime;
        lane.lapHistory.push({ dist: split.dist, lapTime });
        lane.fullLapHistory.push({ rep: lane.currentRep, dist: split.dist, lapTime, totalTime: lane.elapsed });
        lane.lastLapTime = lane.elapsed;
        lane.lapCount++;
        if(lane.lapCount >= lane.targetSplits.length){
          lane.totalTime = lane.elapsed;
          if(lane.currentRep >= pmState.settings.reps){ lane.status='finished'; }
          else { lane.status='resting'; }
        }
      }

      const allFinished = pmState.lanes.every(l=>l.status==='finished');
      if(allFinished){
        pmState.status='finished';
        summary.mode = 'pm';
        summary.data = { settings: pmState.settings, lanes: pmState.lanes };
        buildPmSummary(summary.data);
        openSummary();
        initPacemaker();
        show('pm');
        return;
      }
      renderPacemaker();
    }

    /* ====== Custom Timer ====== */
    let ct={};
    const customBox = document.getElementById('custom-steps-container');
    const customRunner = document.getElementById('custom-runner');
    const customSettings = document.getElementById('custom-settings');
    const customTime = document.getElementById('custom-runner-time');

    function initCustom(){ ct={status:'idle',steps:[{type:'work',duration:30},{type:'rest',duration:10}],reps:1,curRep:1,idx:0,start:0}; renderCustomSettings(); }
    function renderCustomSettings(){ customSettings.classList.remove('hidden'); customRunner.classList.add('hidden'); customBox.innerHTML = ct.steps.map((s,i)=>`<div class='flex items-center gap-2'><select data-i='${i}' class='step-type p-2 border rounded bg-gray-100'><option value='work' ${s.type==='work'?'selected':''}>WORK</option><option value='rest' ${s.type==='rest'?'selected':''}>REST</option></select><input type='number' value='${s.duration}' data-i='${i}' class='step-sec p-2 border rounded w-full' placeholder='秒'><button data-i='${i}' class='rm px-3 py-2 bg-red-500 text-white rounded'>×</button></div>`).join('');
      customBox.querySelectorAll('.step-type').forEach(el=> el.onchange=(e)=>{ ct.steps[+e.target.dataset.i].type = e.target.value; });
      customBox.querySelectorAll('.step-sec').forEach(el=> el.oninput=(e)=>{ ct.steps[+e.target.dataset.i].duration = parseInt(e.target.value)||0; });
      customBox.querySelectorAll('.rm').forEach(el=> el.onclick=(e)=>{ const i=+e.target.dataset.i; if(ct.steps.length>1){ ct.steps.splice(i,1); renderCustomSettings(); } });
      document.getElementById('custom-add-step-btn').onclick=()=>{ ct.steps.push({type:'work',duration:30}); renderCustomSettings(); };
      document.getElementById('custom-start-btn').onclick=()=>{ ct.reps=parseInt(document.getElementById('custom-reps').value)||1; ct.curRep=1; ct.idx=0; ct.status='running'; ct.start=Date.now(); customSettings.classList.add('hidden'); customRunner.classList.remove('hidden'); updateCustomUI(); beep(880,120); };
      document.getElementById('custom-reset-btn').onclick=()=> initCustom();
    }

    function updateCustomUI(){
      document.getElementById('custom-runner-set-info').textContent = `SET ${ct.curRep} / ${ct.reps}`;
      document.getElementById('custom-runner-step-info').textContent = `${ct.steps[ct.idx].type.toUpperCase()} ${ct.idx+1} / ${ct.steps.length}`;
      const cur=ct.steps[ct.idx]; const el=Date.now()-ct.start; const rem=Math.max(0, cur.duration*1000 - el); const sec=Math.ceil(rem/1000); customTime.textContent = String(sec).padStart(2,'0');
      customRunner.classList.toggle('work-bg', cur.type==='work');
      customRunner.classList.toggle('rest-bg', cur.type==='rest');
    }
    function tickCustom(){
      if(ct.status!=='running') return; const cur=ct.steps[ct.idx]; const now=Date.now(); const el= now - ct.start; const rem=cur.duration*1000 - el; if(rem<=0){ ct.idx++; if(ct.idx>=ct.steps.length){ ct.curRep++; if(ct.curRep>ct.reps){ ct.status='idle'; initCustom(); return; } ct.idx=0; } ct.start=now; beep(880,120); } updateCustomUI();
    }

    /* ====== RAF Loop ====== */
    function loop(){
      if(current==='split') tickSplit();
      else if(current==='pm') updatePacemaker();
      else if(current==='custom') tickCustom();
      requestAnimationFrame(loop);
    }

    // 初期表示
    show('chooser');
    initSplit();
    initPacemaker();
    initCustom();
    loop();
  });
  </script>
</body>
</html>
